---
title: "Crypto: Knapsack"
date: 2025-01-08
draft: false
summary: Backdoor CTF 2023. Classic subset sum / knapsack problem solved with LLL.
tags: ["knapsack", "LLL", "matrix"] 
category: Cryptography
---
{{< katex >}}
###### Challenge
Yesterday I stumbled upon a CTF challenge that is about solving a knapsack problem, which is very new to me. After doing that challenge, I am curious and wanted to do more of knapsack problem related challenges in order to learn more about knapsack and the application of LLL to solve the problem, and I found this challenge from Backdoor CTF 2023. 

There are several writeups that I found:
- Meet in The Middle: 
	- https://ctftime.org/writeup/38372
	- https://meashiri.github.io/ctf-writeups/posts/202312-backdoorctf/#knapsack
- Lattice reduction with LLL:
	- https://connor-mccartney.github.io/cryptography/other/BackdoorCTF-2023-writeups
- Lattice reduction with BKZ:
	- https://github.com/tde-nico/backdoor_ctf_2023/blob/main/crypto/knapsack/solve.sage

However in this writeup, we will focus on the writeup that uses lattice reduction methods (especially LLL) since I am trying to learn about it, which is the writeup by ConnorM.

We are provided *script.py* and *output.txt*.

```
# script.py
import random
import hashlib
from Crypto.Util.number import bytes_to_long
from Crypto.Cipher import AES

flag = b"The flag has been REDACTED"
secret = b"The seccret has been REDACTED"
key = hashlib.sha256(secret).digest()[:16]

cipher = AES.new(key, AES.MODE_ECB)
padded_flag = flag + b'\x00'*(-len(flag)%16)

ciphertext = cipher.encrypt(padded_flag)

f = open('output.txt','w')
f.write(f"Ciphertext: {ciphertext.hex()}\n\n")

arr = [ random.randint(1,1000000000000) for i in range(40) ]
k = bytes_to_long(secret)
s = 0
for i in range(40):
    if k&(1<<i):
        s+=arr[i]

f.write(f'numbers: {str(arr)[1:-1]}\nsum: {s}\n')
f.close()
```

```
# output.txt (?)
Ciphertext: af95a58f4fbab33cd98f2bfcdcd19a101c04232ac6e8f7e9b705b942be9707b66ac0e62ed38f14046d1cd86b133ebda9

numbers: 600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979
sum: 7929089016814
```

The flag is AES encrypted with a secret key, and we are only given some numbers related to the secret key to recover the secret key from. The numbers are generated by first getting 40 random numbers. These numbers will then be added to a sum variable `s` depending on the current bit of `k` (0 or 1). Since we have the numbers array `arr` and the sum variable `s` and we have to recover the bits of `k`, this becomes a classic subset-sum problem / knapsack problem (general knapsack).

###### Testing LLL
I've been reading some other writeups and found that subset-sum problem can be solved with LLL. For this particular problem however, I only found [this writeup](https://connor-mccartney.github.io/cryptography/other/BackdoorCTF-2023-writeups) by ConnorM which actually uses LLL to solve the problem. The writeup has a good explanation and steps on creating the initial matrix for LLL reduction, so let's walk through the process. Feel free to skip to the [Solution](#solution) for the solve.

Let's first start by arranging the problem as an equation:

$$sum = arr_0 . b_0 + arr_1 . b_1 + arr_2 . b_2 + \ldots + arr_i . b_i$$
	
with all \\(bi\\) value being either 0 or 1.

We can transform this equation in form of vectors:

$$
b_0 \begin{bmatrix} \text{arr}_0 \\\ 0 \\\ 0 \\\ 0 \\\ 1 \end{bmatrix} + b_1 \begin{bmatrix} \text{arr}_1 \\\ 0 \\\ 0 \\\ 1 \\\ 0 \end{bmatrix} + b_2 \begin{bmatrix} \text{arr}_2 \\\ 0 \\\ 1 \\\ 0 \\\ 0 \end{bmatrix} + b_3 \begin{bmatrix} \text{arr}_3 \\\ 1 \\\ 0 \\\ 0 \\\ 0 \end{bmatrix} + 1 \begin{bmatrix} -s \\\ 0 \\\ 0 \\\ 0 \\\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\\ b_3 \\\ b_2 \\\ b_1 \\\ b_0 \end{bmatrix}
$$

These vectors form the lattice basis vectors for us to use in matrix `M`.


$$
M = \begin{bmatrix}1 & 0 & 0 & 0 & arr_0 \\\ 0 & 1 & 0 & 0 & arr_1 \\\ 0 & 0 & 1 & 0 & arr_2 \\\ 0 & 0 & 0 & 1 & arr_3 \\\ 0 & 0 & 0 & 0 & -s\end{bmatrix}
$$

When we apply LLL to this matrix \\(M\\), our target is to have one of the rows of the resulting matrix to be the vector on the right hand-side of the equation. Let's give it a try using Sagemath.

```
arr = [600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979]
s = 7929089016814
n = len(arr)

M = Matrix(ZZ, n+1, n+1)
for i in range(n):
	M[i, i] = 1
	M[i, -1] = arr[i]
M[-1, -1] = -s

Mr = M.LLL()
print(Mr)
```

![Image Description](/images/Pasted%20image%2020250107201020.png)

We can see that we successfully applied LLL and reduced the basis vectors into smaller ones, but if we check the result, none of them consists of only two numbers representing the bits, so we don't have our correct result yet. 

We can improve the basis vectors by including guesses for the value of \\(b_i\\). The value of \\(b_i\\) can either be 0 or 1, so we can take the average, being 1/2. This also means that our target vector needs to be added with 1/2 to get the actual value of \\(b_i\\).

$$
b_0 \begin{bmatrix} \text{arr}_0 \\\ 0 \\\ 0 \\\ 0 \\\ 1 \end{bmatrix} + b_1 \begin{bmatrix} \text{arr}_1 \\\ 0 \\\ 0 \\\ 1 \\\ 0 \end{bmatrix} + b_2 \begin{bmatrix} \text{arr}_2 \\\ 0 \\\ 1 \\\ 0 \\\ 0 \end{bmatrix} + b_3 \begin{bmatrix} \text{arr}_3 \\\ 1 \\\ 0 \\\ 0 \\\ 0 \end{bmatrix} + 1 \begin{bmatrix} -s \\\ -1/2 \\\ -1/2 \\\ -1/2 \\\ -1/2 \end{bmatrix} = \begin{bmatrix} 0 \\\ b_3 -1/2 \\\ b_2 -1/2 \\\ b_1 -1/2 \\\ b_0 -1/2 \end{bmatrix}
$$

$$
M = \begin{bmatrix}1 & 0 & 0 & 0 & arr_0 \\\ 0 & 1 & 0 & 0 & arr_1 \\\ 0 & 0 & 1 & 0 & arr_2 \\\ 0 & 0 & 0 & 1 & arr_3 \\\ -1/2 & -1/2 & -1/2 & -1/2 & -s\end{bmatrix}
$$

We can also improve the lattice by scaling each first component of the basis vectors by \\(N\\) for \\(N = \operatorname{ceil}({\frac{\sqrt{length}}{2}})\\). This won't affect the resulting vector on the RHS. If we test it with the function above, we can see that this yield better results too.

$$
b_0 \begin{bmatrix} N.arr_0 \\\ 0 \\\ 0 \\\ 0 \\\ 1 \end{bmatrix} + b_1 \begin{bmatrix} N.arr_1 \\\ 0 \\\ 0 \\\ 1 \\\ 0 \end{bmatrix} + b_2 \begin{bmatrix} N.arr_2 \\\ 0 \\\ 1 \\\ 0 \\\ 0 \end{bmatrix} + b_3 \begin{bmatrix} N.arr_3 \\\ 1 \\\ 0 \\\ 0 \\\ 0 \end{bmatrix} + 1 \begin{bmatrix} -N.s \\\ -1/2 \\\ -1/2 \\\ -1/2 \\\ -1/2 \end{bmatrix} = \begin{bmatrix} 0 \\\ b_3 -1/2 \\\ b_2 -1/2 \\\ b_1 -1/2 \\\ b_0 -1/2 \end{bmatrix}
$$

$$
M = \begin{bmatrix}1 & 0 & 0 & 0 & N.arr_0 \\\ 0 & 1 & 0 & 0 & N.arr_1 \\\ 0 & 0 & 1 & 0 & N.arr_2 \\\ 0 & 0 & 0 & 1 & N.arr_3 \\\ -1/2 & -1/2 & -1/2 & -1/2 & -N.s\end{bmatrix}
$$

I modified the script by ConnorM to also test the scaled improved basis, so we will be testing three basis vectors performance when we do LLL on it:

```
from random import randint

def previous_basis(length):
    arr = [ randint(1,1000000000000) for _ in range(length) ]
    s = sum([i for i in arr if randint(0, 1) == 0])
    M = identity_matrix(len(arr))
    M = M.augment(vector(arr))
    M = M.stack(vector([0 for _ in range(len(arr))] + [-s]))

    for row in M.LLL():
        for row in (row, -row):
            if row[-1] == 0:
                subset = [arr[i] for i, x in enumerate(row[:-1]) if x==1]
                if sum(subset) == s:
                    return True
    return False


def improved_basis(length):
    arr = [ randint(1,1000000000000) for _ in range(length) ]
    s = sum([i for i in arr if randint(0, 1) == 0])
    M = identity_matrix(QQ, len(arr))
    M = M.augment(vector(arr))
    M = M.stack(vector([-1/2 for _ in range(len(arr))] + [-s]))

    for row in M.LLL():
        for row in (row, -row):
            if row[-1] == 0:
                subset = [arr[i] for i, x in enumerate(row[:-1]) if x+1/2==1]
                if sum(subset) == s:
                    return True
    return False

def improved_basis_2(length):
    arr = [ randint(1,1000000000000) for _ in range(length) ]
    s = sum([i for i in arr if randint(0, 1) == 0])
    n = len(arr)
    N = ceil(sqrt(n) / 2)
    M = Matrix(QQ, n + 1, n + 1)
    for i in range(n):
        M[i, i] = 1
        M[i, -1] = N * arr[i]
        M[-1, i] = -1/2
    M[-1, -1] = -N * s

    for row in M.LLL():
        for row in (row, -row):
            if row[-1] == 0:
                subset = [arr[i] for i, x in enumerate(row[:-1]) if x+1/2==1]
                if sum(subset) == s:
                    return True
    return False 

def test(f, length):
    n = 100
    count = 0
    for _ in range(n):
        if f(length):
            count += 1
    return f'{float(count/n):.2%}'

for length in range(10, 45):
    print(f"{length = }:")
    print("prev", test(previous_basis, length))
    print("impr", test(improved_basis, length))
    print("impr2", test(improved_basis_2, length))
    print()
```

And here's the result of testing the three vector basis:

| Length | Prev (%) | Impr (%) | Impr2 (%) |
|--------|----------|----------|-----------|
| 10     | 100.00   | 100.00   | 100.00    |
| 11     | 100.00   | 100.00   | 100.00    |
| 12     | 100.00   | 100.00   | 100.00    |
| 13     | 100.00   | 100.00   | 100.00    |
| 14     | 100.00   | 100.00   | 100.00    |
| 15     | 100.00   | 100.00   | 100.00    |
| 16     | 100.00   | 100.00   | 100.00    |
| 17     | 100.00   | 100.00   | 100.00    |
| 18     | 100.00   | 100.00   | 100.00    |
| 19     | 100.00   | 100.00   | 100.00    |
| 20     | 100.00   | 100.00   | 100.00    |
| 21     | 100.00   | 100.00   | 100.00    |
| 22     | 97.00    | 100.00   | 100.00    |
| 23     | 95.00    | 100.00   | 100.00    |
| 24     | 87.00    | 100.00   | 100.00    |
| 25     | 84.00    | 100.00   | 100.00    |
| 26     | 63.00    | 100.00   | 100.00    |
| 27     | 43.00    | 100.00   | 100.00    |
| 28     | 47.00    | 100.00   | 100.00    |
| 29     | 32.00    | 98.00    | 96.00     |
| 30     | 24.00    | 97.00    | 99.00     |
| 31     | 29.00    | 85.00    | 94.00     |
| 32     | 7.00     | 81.00    | 87.00     |
| 33     | 5.00     | 64.00    | 73.00     |
| 34     | 5.00     | 51.00    | 65.00     |
| 35     | 3.00     | 39.00    | 60.00     |
| 36     | 2.00     | 36.00    | 46.00     |
| 37     | 1.00     | 14.00    | 27.00     |
| 38     | 0.00     | 15.00    | 26.00     |
| 39     | 1.00     | 6.00     | 14.00     |
| 40     | 0.00     | 2.00     | 4.00      |

We can see that the previous (starting) basis has lower accuracy than the improved basis. The second improved basis also has a higher average accuracy than the first improved basis. However, to solve this problem where the basis has the length of 40, this is not enough as we still only have a low chance that it will generate the correct result.

###### Solution
The secret number or `k` can't have all of its bits being 1, so we can attempt to reduce the size of the matrix by brute-forcing the combinations of a smaller subset, like the subset of the array with the size of 39 numbers (one number less). By combining this with the second improved basis, we can get the bits of the `secret` in one of the resulting vectors. We can then use the bits to reconstruct `secret` and using it as the decryption key to get the flag.

```
# solve.sage
from itertools import combinations
from Crypto.Util.number import long_to_bytes
from Crypto.Cipher import AES
from hashlib import sha256

def improved_basis_2(arr, s):
    n = len(arr)
    N = ceil(sqrt(n) / 2)
    M = Matrix(QQ, n + 1, n + 1)
    for i in range(n):
        M[i, i] = 1
        M[i, -1] = N * arr[i]
        M[-1, i] = -1/2
    M[-1, -1] = -N * s

    for row in M.LLL():
        for row in (row, -row):
            k = [i + 1/2 for i in row[:-1]]
            if all([i in (0, 1) for i in k]):
                subset = [val for val, currbit in zip(arr, k) if currbit == 1]
                if sum(subset) == s:
                    return subset
    return False 

def brute_subsets(arr, s, length):
    for subset in combinations(arr, length):
        res = improved_basis_2(subset, s)
        if res:
            return res

ct = bytes.fromhex("af95a58f4fbab33cd98f2bfcdcd19a101c04232ac6e8f7e9b705b942be9707b66ac0e62ed38f14046d1cd86b133ebda9")
arr = [600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979]
s = 7929089016814
n = len(arr)

ans = brute_subsets(arr, s, len(arr) - 1)
secret = long_to_bytes(sum([2**i for i in range(len(arr)) if arr[i] in ans]))
key = sha256(secret).digest()[:16]
cipher = AES.new(key, AES.MODE_ECB)
print(cipher.decrypt(ct))
```

Flag: `flag{N0t_r34dy_f0r_M3rkl3-H3llman}`

Link, resources:
- https://connor-mccartney.github.io/cryptography/other/BackdoorCTF-2023-writeups
- https://github.com/tde-nico/backdoor_ctf_2023/blob/main/crypto/knapsack/solve.sage
- https://ctf-wiki.mahaloz.re/crypto/asymmetric/knapsack/knapsack/
