
[{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/tags/aes/","section":"Tags","summary":"","title":"AES","type":"tags"},{"content":" Decompiling the Source # Challenge files: here\nIn this challenge, we are provided with chall.zip, out.txt, and pairs.txt. The zip archive contains chall.cpython-311.pyc, utils.cpython-311.pyc, aes.cpython-311.pyc.\nThe challenge source code is compiled Python, which can be decompiled with https://pylingual.io/. The decompiled code shows obfuscated variable name, so I asked ChatGPT to change the variable names into a more readable format.\nUnderstanding the Challenge # Challenge Functions # One of the given files is the source code for AES implementation. This usually hints that the AES used is customized (a non-standard AES).\nThe challenge starts with generating a random 16 bytes key for AES and calls the function generate_encryption_pairs(). This function creates five blocks with the length of 16 bytes, where the first 4 bytes of each blocks are unique random bytes and the remaining 12 bytes of the blocks are null bytes. It will then encrypt the blocks with custom_encrypt() function. The raw blocks and encrypted blocks are then used to create the encryption pairs.\n# Example of a single encryption pair 176a3336000000000000000000000000 56d32528000000000000000000000000 a6830b1a039cf44917aba0318057cea5 50cfdab0b57af032d3c5bd76077a305d The custom_encrypt() function starts by creating an instance of the AES class, passing KEY and 2 as parameters. The 2 here shouldn\u0026rsquo;t exist in regular AES implementation, so that\u0026rsquo;s something that we should take a look on. After creating the instance, it encrypts the block normally with AES, followed by add_round_key(), mix_columns(), and add_round key() again, then it returns the resulting block.\nAES in a Nutshell # Here\u0026rsquo;s how AES encryption works in a nutshell:\nThe master key of AES is expanded into multiple round keys using AES key schedule. There are four main functions. AddRoundKey, where the state is XOR-ed with the round key. SubBytes, where each byte of the state is replaced with another byte based on a lookup table. ShiftRows, where the rows are shifted based on their position, second row shifted by 1, third row by 2, and last row by 3. MixColumns, where the four bytes of each column are combined and mixed together, The first phase is pre-whitening, which is done by performing AddRoundKey. After the first phase, there will be n-1 rounds done for n is the number of AES rounds. For each round, these steps will be performed sequentially: SubBytes \u0026gt; ShiftRows \u0026gt; MixColumns \u0026gt; AddRoundKey. This is called as full round. After it is done, a final round takes place where the steps are the same except that now there is no MixColumns: SubBytes \u0026gt; ShiftRows \u0026gt; AddRoundKey. This is also called as half-round. The Vulnerability # The first unique thing in the encryption here is the creation of the AES instance with AES(KEY, 2). If we take a look at the decompiled code, we can see that 2 stands for the number of rounds. A normal 128-bit (16 bytes) AES will do 10 rounds, but in this one only 2 happens. Also since the custom encryption function adds AddRoundKey \u0026gt; MixColumns \u0026gt; AddRoundKey on top of the encryption, the final round which is usually a half round became a full round instead.\nBased on the information, we can conclude that the AES encryption uses only 2 full rounds of encryption instead of the standard 10 rounds (9 full + 1 half). This means that the encrypted block of AES is not mixed properly yet, allowing us to perform Linear and Differential Cryptanalysis which allows us to retrieve the AES master key.\nAttacking the Cipher # Differential Cryptanalysis # I browsed around for possible attacks on low round AES and I found BlockBreakers by David Wong which shows an attack called Square attack for breaking 4-6 rounds of AES. However, this is not the one I am looking for and I was unable to solve this challenge during the time limit (so this is an up-solve).\nAfter the competition, found that the keyword \u0026ldquo;AES low round attack\u0026rdquo; leads to this blog by Merricx that shows the exact attack that I need. The blog explains about how to break 1 to 3-round AES, which includes Differential chosen-plaintext attack to break two full rounds of AES.\nThe attack used is a chosen-plaintext attack because we need the plaintext differential where the first column is non-zero differential and the rest are zero differential, which is quite specific. Thankfully the plaintext-ciphertext pairs given in pairs.txt already fit this criteria, where the first four bytes (first column) are random bytes and the remaining bytes are null bytes (00). This means that this must be the correct attack.\nPerforming the Attack # Since I can\u0026rsquo;t explain the attack better than the original blog by Merricx, which contains a really good explanation already, I\u0026rsquo;ll go straight to attacking it. This part is really simple because apparently the blog provides the Python implementation of the attack found here as round2-full-impossible-diff.py, which is an Impossible Differential chosen-plaintext attack that requires five plaintext-ciphertext pairs, exactly what we have right now.\nAfter a slight modification to the script to parse the plaintext-ciphertext pairs and also to decrypt with the obtained key, we should be able to get the flag.\nimport os, random from Crypto.Util.strxor import strxor from itertools import product from aes import AES from utils import * def decrypt(ciphertext, key): aes = AES(key, 2) key_expand = aes._key_matrices state = bytes2matrix(ciphertext) add_round_key(state, key_expand[-1]) inv_mix_columns(state) add_round_key(state, key_expand[-1]) return aes.decrypt_block(matrix2bytes(state)) def generate_sbox_different_distribution_table(): table = {} for i in range(256): for j in range(256): diff = i ^ j diff_sbox = sbox[i] ^ sbox[j] if diff in table: if diff_sbox not in table[diff]: table[diff].append(diff_sbox) else: table[diff] = [diff_sbox] return table def inv_last_round(s, k): state = bytes2matrix(s) round_key = bytes2matrix(k) inv_mix_columns(state) add_round_key(state, round_key) inv_shift_rows(state) inv_sub_bytes(state) return matrix2bytes(state) def mix_columns_key(round_key): state = bytes2matrix(round_key) mix_columns(state) return matrix2bytes(state) def generate_impossible_state(differential): impossible = [] for i in range(4): impossible.append([]) for j in range(256): if j not in sbox_ddt[differential[i]]: impossible[i].append(j) impossible_state = [] for i in range(4): for j in impossible[i]: state = bytes2matrix(b\u0026#39;\\x00\u0026#39;*(i) + bytes([j]) + b\u0026#39;\\x00\u0026#39;*(15-i)) shift_rows(state) mix_columns(state) impossible_state.append(matrix2bytes(state)) return impossible_state def generate_256_list(): result = [] for i in range(256): result.append(i) return result shifted_round1 = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11] sbox_ddt = generate_sbox_different_distribution_table() print(\u0026#34;[+] Retrieve 5 plaintext-ciphertext pairs from encryption oracle...\u0026#34;) test_pair = [[bytes.fromhex(block) for block in pair.split(\u0026#34;\\n\u0026#34;)] for pair in open(\u0026#34;../pairs.txt\u0026#34;).read().split(\u0026#34;\\n\\n\u0026#34;)[:-1]] impossible_key = [None] * 16 for plaintext1, plaintext2, ciphertext1, ciphertext2 in test_pair: print(\u0026#34;[+] Checking impossible state from differential pair...\u0026#34;) plain_diff = xor(plaintext1, plaintext2) enc_diff = xor(ciphertext1, ciphertext2) impossible_state = generate_impossible_state(plain_diff) for i in range(16): if impossible_key[i] is None: impossible_key[i] = [] shifted_index = shifted_round1[i] for j in range(256): if j in impossible_key[i]: continue guess_key = b\u0026#39;\\x00\u0026#39;*(i) + bytes([j]) + b\u0026#39;\\x00\u0026#39;*(15-i) inv_a = inv_last_round(ciphertext1, guess_key) inv_b = inv_last_round(ciphertext2, guess_key) inv_diff = xor(inv_a, inv_b) for k in impossible_state: if inv_diff[shifted_index] == k[shifted_index]: impossible_key[i].append(j) list_256 = generate_256_list() possible_key = [] for imp_key in impossible_key: possible_key.append(list(set(list_256) - set(imp_key))) all_possible_key = product(*possible_key) ciphertext_check = ciphertext1 for possible_round_key in all_possible_key: mixed_key = mix_columns_key(possible_round_key) master_key = inv_key_expansion(list(mixed_key), 2) decrypt_check = decrypt(ciphertext_check, master_key) if decrypt_check == test_pair[-1][0]: print(\u0026#39;[+] Possible Master Key:\u0026#39;, master_key) encs = [bytes.fromhex(enc) for enc in open(\u0026#34;../out.txt\u0026#34;).read().split(\u0026#34;\\n\u0026#34;)] pts = [decrypt(enc, master_key) for enc in encs] print(\u0026#34;[+] Flag:\u0026#34;, b\u0026#39;\u0026#39;.join(pts)) ┌──(chronopad㉿VincentXPS)-[~/Documents/ctf2025/AraCTF-Finals_2025/a2s-upsolve/aes-attack] └─$ python3 round2-full-impossible-diff.py [+] Retrieve 5 plaintext-ciphertext pairs from encryption oracle... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Checking impossible state from differential pair... [+] Possible Master Key: b\u0026#39;\\xc3\\x01\\xa7\\xd71\\xe1O\\xd1y\\xf5Tm\\x1c\\xb95\\xae\u0026#39; [+] Flag: b\u0026#39;ARA6{2rounds_of_AES_arent_enough_hmmmm_maybe_3?}\u0026#39; Flag: ARA6{2rounds_of_AES_arent_enough_hmmmm_maybe_3?}\nResources # https://en.wikipedia.org/wiki/Advanced_Encryption_Standard https://www.davidwong.fr/blockbreakers/aes_10_encryption.html https://merri.cx/adventure-of-aes/ https://github.com/Merricx/aes-attack ","date":"26 February 2025","externalUrl":null,"permalink":"/ctf/aractf2025/a2s_3c/","section":"CTF Writeups","summary":"Differential Cryptanalysis to recover encryption key on reduced round AES.","title":"ARA CTF 6.0 2025 Finals: a2s 3c","type":"ctf"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/","section":"Chrono Nexus","summary":"","title":"Chrono Nexus","type":"page"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/tags/cryptanalysis/","section":"Tags","summary":"","title":"Cryptanalysis","type":"tags"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/ctf/","section":"CTF Writeups","summary":"","title":"CTF Writeups","type":"ctf"},{"content":"","date":"26 February 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Challenge Analysis # Challenge file: here\nThe challenge only provides us with chall.py and a connection to server.\nMain Function # The challenge starts by encrypting PASSWORD with AES and a random IV. It uses AES implementation from PyCryptodome, so let\u0026rsquo;s take a look at the docs to see which AES mode is used. Based on the documentation, AES mode 5 is the OFB (Output Feedback) mode. It then prints out the encrypted password along with the IV.\nAfter that, the challenge turns into an encryption and decryption oracle, giving us three chances to do three different types of actions, being:\nEncrypt, where we can encrypt any message using the parameters that we input. Decrypt, where we can decrypt any message using the parameters that we input. Guess, where we can guess the value of PASSWORD, also giving us the flag if we guessed correctly. User Input Function # This function takes in the data to encrypt/decrypt in the form of hex encoding and also the AES parameters in form of JSON. There\u0026rsquo;s a check in this function to ensure that the data length is under 41 bytes, which also means that we can only encrypt 32 bytes max or 2 blocks of AES since AES only accepts increment of 16 bytes.\nCheck Mode Function # This function is the main problem of this challenge. Every encryption and decryption done will check and store the AES mode to used list, so we can\u0026rsquo;t use the same mode twice for the oracle. The challenge here is to decrypt the encrypted password, which spans four blocks, within two actions of encryption and decryption. We can only do two actions since the last one will be used to guess the password.\nDecrypting the Password # Attack Preparation # Let\u0026rsquo;s start by taking a look at the OFB mode encryption. Here we can see that the plaintext is XOR-ed with encrypted IV to get the first ciphertext. The encrypted IV is further encrypted to be XOR-ed with the next ciphertext.\n# Encryption model PASSWORD_BLOCK1 ^ ENC(IV) = CIPHERTEXT_BLOCK1 PASSWORD_BLOCK2 ^ ENC(ENC(IV)) = CIPHERTEXT_BLOCK2 PASSWORD_BLOCK3 ^ ENC(ENC(ENC(IV))) = CIPHERTEXT_BLOCK3 PASSWORD_BLOCK4 ^ ENC(ENC(ENC(ENC(IV)))) = CIPHERTEXT_BLOCK4 Based on the above encryption model, we know that we can recover the password by getting the ENC(IV), ENC(ENC(IV)), ENC(ENC(ENC(IV))), ENC(ENC(ENC(ENC(IV)))), which is just the IV encrypted once - IV encrypted four times with AES. We can encrypt two blocks at once, so we have to find a mode that encrypts the ciphertext of the first block to get the ciphertext of the next block in order to get the IV encrypted twice in one action. If we can find two modes that can do that, we can recover the password in just two actions (four blocks).\nFirst Action: CBC Mode # Take a look at the CBC (Cipher Block Chaining) mode encryption. Here, the resulting ciphertext from block cipher encryption is XOR-ed with the next plaintext, then encrypted again using block cipher encryption.\nIf we set the IV with the IV from the encrypted password then set the plaintext as 32 bytes as null bytes, XOR(plaintext, IV) will result in the IV itself. The IV will then be encrypted to be ENC(IV) as the first block. The encrypted IV is then XOR-ed with more null bytes to still be ENC(IV). It is then encrypted and we get ENC(ENC(IV)) as the second block.\nSecond Action: CFB Mode # For the second action, we\u0026rsquo;ll use the CFB (Cipher Feedback) mode, with the encryption as seen below.\nWhen the IV is set as ENC(ENC(IV)) and the plaintext is 2 blocks of null bytes, the resulting ciphertext will be XOR(ENC(ENC(ENC(IV))), NULL) or ENC(ENC(ENC(IV))) as the first block. This will then be encrypted again and XOR-ed with null bytes to get ENC(ENC(ENC(ENC(IV)))) as the second block.\nPerforming the Attack # Here\u0026rsquo;s a quick refresher on the encryption model.\n# Encryption model PASSWORD_BLOCK1 ^ ENC(IV) = CIPHERTEXT_BLOCK1 PASSWORD_BLOCK2 ^ ENC(ENC(IV)) = CIPHERTEXT_BLOCK2 PASSWORD_BLOCK3 ^ ENC(ENC(ENC(IV))) = CIPHERTEXT_BLOCK3 PASSWORD_BLOCK4 ^ ENC(ENC(ENC(ENC(IV)))) = CIPHERTEXT_BLOCK4 Now that we have gathered all the required blocks of encrypted IV, all we need to do is to XOR them with the encrypted password to get the plaintext PASSWORD, then submit it to get the flag. Let\u0026rsquo;s compile all of it into a Python script and run it.\nfrom pwn import * def repeatingXor(ct, key): print(len(ct), len(key)) res = [ct[i] ^ key[i % len(key)] for i in range(len(ct))] return bytes(res) io = remote(\u0026#34;20.6.89.33\u0026#34;, 8040) # io = process([\u0026#34;python3\u0026#34;, \u0026#34;chall.py\u0026#34;]) io.recvuntil(b\u0026#34;Encrypted password: \u0026#34;) ct = io.recvline().strip().decode() io.recvuntil(b\u0026#34;IV: \u0026#34;) iv = io.recvline().strip().decode() print(\u0026#34;ct:\u0026#34;, ct) print(\u0026#34;iv:\u0026#34;, iv) # CBC mode for the first two blocks io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) data = b\u0026#34;00\u0026#34; * 32 io.sendlineafter(b\u0026#34;Data: \u0026#34;, data) params = \u0026#39;{\u0026#34;mode\u0026#34;: 2, \u0026#34;iv\u0026#34;: \u0026#34;\u0026#39; + iv + \u0026#39;\u0026#34;}\u0026#39; io.sendlineafter(b\u0026#34;Params: \u0026#34;, params.encode()) io.recvuntil(b\u0026#34;Result: \u0026#34;) first_part = io.recvline().strip().decode() # CFB mode for the last two blocks io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) data = b\u0026#34;00\u0026#34; * 32 io.sendlineafter(b\u0026#34;Data: \u0026#34;, data) params = \u0026#39;{\u0026#34;mode\u0026#34;: 3, \u0026#34;iv\u0026#34;: \u0026#34;\u0026#39; + first_part[32:] + \u0026#39;\u0026#34;, \u0026#34;segment_size\u0026#34;: 128}\u0026#39; io.sendlineafter(b\u0026#34;Params: \u0026#34;, params.encode()) io.recvuntil(b\u0026#34;Result: \u0026#34;) second_part = io.recvline().strip().decode() fullkey = first_part + second_part password = repeatingXor(bytes.fromhex(ct), bytes.fromhex(fullkey)) print(\u0026#34;Password:\u0026#34;, password) io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;Guess: \u0026#34;, password) io.interactive() ┌──(chronopad㉿VincentXPS)-[~/Documents/ctf2025/CyberJawara_2024/classselect/solve] └─$ python3 solve.py [+] Opening connection to 20.6.89.33 on port 8040: Done ct: 1c2b658a97523abe1a0a2d8805d976618f46b0feb62796374472503a2940319e3529c967b37fd82ad946d3033be3c607be1dcb8374b72081f798232ed665e39d iv: 833cd2ac03e9321e0cf0e8ccf3c798c8 64 64 Password: b\u0026#39;4f8b03e4ffe75f677c7b76d1c6c67a7419f952c4625c97ef55d9aa8c2040470b\u0026#39; [*] Switching to interactive mode Gratz: CJ{deploying_on_dday_is_not_a_good_idea_54aa921ee9486967} [*] Got EOF while reading in interactive $ Flag: CJ{deploying_on_dday_is_not_a_good_idea_54aa921ee9486967}\nResources # https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation ","date":"12 January 2025","externalUrl":null,"permalink":"/ctf/cj2024/class_select/","section":"CTF Writeups","summary":"Abusing the encryption of other AES modes to break AES OFB mode.","title":"Cyber Jawara National 2024: Class Select","type":"ctf"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/mode-abuse/","section":"Tags","summary":"","title":"Mode-Abuse","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/htb/","section":"HTB Writeups","summary":"","title":"HTB Writeups","type":"htb"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]